{
	"name": "dp_Person_Dim_df1",
	"properties": {
		"type": "MappingDataFlow",
		"typeProperties": {
			"sources": [
				{
					"dataset": {
						"referenceName": "AzureSynpMxmStgRefnAsset22",
						"type": "DatasetReference"
					},
					"name": "srcPersonLd"
				},
				{
					"dataset": {
						"referenceName": "OrgSiteRefRd7",
						"type": "DatasetReference"
					},
					"name": "srcPersonSiteRefRd"
				},
				{
					"dataset": {
						"referenceName": "OrgSiteRefRd7",
						"type": "DatasetReference"
					},
					"name": "PersonExistRowRd"
				},
				{
					"dataset": {
						"referenceName": "OrgSiteRefRd7",
						"type": "DatasetReference"
					},
					"name": "MaxKey"
				}
			],
			"sinks": [
				{
					"dataset": {
						"referenceName": "SinkPersonInitialLoad1",
						"type": "DatasetReference"
					},
					"name": "sinkPersonLd"
				},
				{
					"dataset": {
						"referenceName": "SinkPersonInitialLoad1",
						"type": "DatasetReference"
					},
					"name": "sinkPersonUpdate"
				}
			],
			"transformations": [
				{
					"name": "dcPersonLd"
				},
				{
					"name": "skPersonLd"
				},
				{
					"name": "lkpPersonSite"
				},
				{
					"name": "selPersonExistRow"
				},
				{
					"name": "dcPersonHashKey"
				},
				{
					"name": "existsPerson"
				},
				{
					"name": "lookupPerson"
				},
				{
					"name": "splitPerson"
				},
				{
					"name": "joinPerson"
				},
				{
					"name": "dcPersonInsert"
				},
				{
					"name": "selPersonInsert"
				},
				{
					"name": "alterRowInsert"
				},
				{
					"name": "dcPersonUpdate"
				},
				{
					"name": "selPersonUpdate"
				},
				{
					"name": "alterRowUpdate"
				}
			],
			"scriptLines": [
				"source(output(",
				"          PERSON_NBR as string,",
				"          PERSON_FIRST_NM as string,",
				"          PERSON_LAST_NM as string,",
				"          STATUS as string,",
				"          DEPARTMENT as string,",
				"          TITLE as string,",
				"          EMPLOYEE_TYPE as string,",
				"          JOBCODE as string,",
				"          SUPERVISOR as string,",
				"          BIRTHDATE as date,",
				"          HIREDATE as date,",
				"          TERMINATIONDATE as date,",
				"          LOCATION as string,",
				"          LOCATIONSITE as string,",
				"          STATUSDATE as timestamp",
				"     ),",
				"     allowSchemaDrift: true,",
				"     validateSchema: false,",
				"     isolationLevel: 'READ_UNCOMMITTED',",
				"     query: '\\nSELECT \\nPERSONID AS PERSON_NBR,\\nFIRSTNAME AS PERSON_FIRST_NM,\\nLASTNAME AS PERSON_LAST_NM,\\nSTATUS AS STATUS,\\nDEPARTMENT AS DEPARTMENT,\\nTITLE AS TITLE,\\nEMPLOYEETYPE AS EMPLOYEE_TYPE,\\nJOBCODE AS JOBCODE,\\nSUPERVISOR AS SUPERVISOR,\\nBIRTHDATE,\\nHIREDATE,\\nTERMINATIONDATE,\\nLOCATION,\\nLOCATIONSITE,\\nSTATUSDATE\\nFROM MXMSTG.STG_PERSON',",
				"     format: 'query',",
				"     staged: true) ~> srcPersonLd",
				"source(output(",
				"          SITE_ID as integer,",
				"          SITE_NM as string",
				"     ),",
				"     allowSchemaDrift: true,",
				"     validateSchema: false,",
				"     isolationLevel: 'READ_UNCOMMITTED',",
				"     query: 'SELECT SITE_ID,SITE_NM FROM MXMDW.SITE',",
				"     format: 'query',",
				"     staged: true) ~> srcPersonSiteRefRd",
				"source(output(",
				"          PERSON_ID as integer,",
				"          PERSON_NBR as string,",
				"          STATUS as string,",
				"          DEPARTMENT as string,",
				"          JOBCODE as string,",
				"          SUPERVISOR as string,",
				"          SRC_TYPE_HASH_KEY as string",
				"     ),",
				"     allowSchemaDrift: true,",
				"     validateSchema: false,",
				"     isolationLevel: 'READ_UNCOMMITTED',",
				"     query: 'SELECT PERSON_ID,PERSON_NBR,STATUS,DEPARTMENT,JOBCODE,SUPERVISOR,SRC_TYPE_HASH_KEY FROM MXMDW.PERSON',",
				"     format: 'query',",
				"     staged: true,",
				"     partitionBy('hash', 1)) ~> PersonExistRowRd",
				"source(output(",
				"          MAXKEY as integer",
				"     ),",
				"     allowSchemaDrift: true,",
				"     validateSchema: false,",
				"     isolationLevel: 'READ_UNCOMMITTED',",
				"     query: 'SELECT MAXKEY=ISNULL(MAX(PERSON_ID),0) FROM MXMDW.PERSON',",
				"     format: 'query',",
				"     staged: true) ~> MaxKey",
				"lkpPersonSite derive(PERSON_FIRST_NM = iifNull(PERSON_FIRST_NM, 'NA', PERSON_FIRST_NM),",
				"          PERSON_LAST_NM = iifNull(PERSON_LAST_NM, 'NA', PERSON_LAST_NM),",
				"          STATUS = iifNull(STATUS, 'NA', STATUS),",
				"          DEPARTMENT = iifNull(DEPARTMENT, 'NA', DEPARTMENT),",
				"          TITLE = iifNull(TITLE, 'NA', TITLE),",
				"          EMPLOYEE_TYPE = iifNull(EMPLOYEE_TYPE, 'NA', EMPLOYEE_TYPE),",
				"          JOBCODE = iifNull(JOBCODE, 'NA', JOBCODE),",
				"          SUPERVISOR = iifNull(SUPERVISOR, 'NA', SUPERVISOR),",
				"          BIRTHDATE = iifNull(BIRTHDATE, toDate('1900/01/01','yyyy/MM/dd'), BIRTHDATE),",
				"          HIREDATE = iifNull(HIREDATE, toDate('1900/01/01','yyyy/MM/dd'), HIREDATE),",
				"          LOCATION = iifNull(LOCATION, 'NA', LOCATION)) ~> dcPersonLd",
				"joinPerson keyGenerate(output(NewPERSON_ID as long),",
				"     startAt: 1L,",
				"     stepValue: 1L,",
				"     partitionBy('hash', 1)) ~> skPersonLd",
				"srcPersonLd, srcPersonSiteRefRd lookup(LOCATIONSITE == SITE_NM,",
				"     multiple: false,",
				"     pickup: 'any',",
				"     broadcast: 'auto')~> lkpPersonSite",
				"PersonExistRowRd select(mapColumn(",
				"          ExistPERSON_ID = PERSON_ID,",
				"          ExistPERSON_NBR = PERSON_NBR,",
				"          ExistSTATUS = STATUS,",
				"          ExistDEPARTMENT = DEPARTMENT,",
				"          ExistJOBCODE = JOBCODE,",
				"          ExistSUPERVISOR = SUPERVISOR,",
				"          ExistSRC_TYPE_HASH_KEY = SRC_TYPE_HASH_KEY",
				"     ),",
				"     partitionBy('hash', 1),",
				"     skipDuplicateMapInputs: true,",
				"     skipDuplicateMapOutputs: true) ~> selPersonExistRow",
				"dcPersonLd derive(SRC_TYPE_HASH_KEY = sha2(256,PERSON_NBR,STATUS,DEPARTMENT,JOBCODE,SUPERVISOR)) ~> dcPersonHashKey",
				"dcPersonHashKey, selPersonExistRow exists(PERSON_NBR == ExistPERSON_NBR",
				"     && STATUS == ExistSTATUS",
				"     && DEPARTMENT == ExistDEPARTMENT",
				"     && JOBCODE == ExistJOBCODE",
				"     && SUPERVISOR == ExistSUPERVISOR,",
				"     negate:true,",
				"     partitionBy('hash', 1),",
				"     broadcast: 'right')~> existsPerson",
				"existsPerson, selPersonExistRow lookup(PERSON_NBR == ExistPERSON_NBR,",
				"     multiple: false,",
				"     pickup: 'any',",
				"     partitionBy('hash', 1),",
				"     broadcast: 'auto')~> lookupPerson",
				"lookupPerson split(isNull(ExistPERSON_ID),",
				"     disjoint: false,",
				"     partitionBy('hash', 1)) ~> splitPerson@(NewItem, UpdateItem)",
				"splitPerson@NewItem, MaxKey join(1==1,",
				"     joinType:'cross',",
				"     matchType:'exact',",
				"     ignoreSpaces: false,",
				"     partitionBy('hash', 1),",
				"     broadcast: 'auto')~> joinPerson",
				"skPersonLd derive(NewPERSON_ID = NewPERSON_ID + MAXKEY,",
				"          EFFECTIVE_DT = currentTimestamp()) ~> dcPersonInsert",
				"dcPersonInsert select(mapColumn(",
				"          PERSON_NBR,",
				"          PERSON_FIRST_NM,",
				"          PERSON_LAST_NM,",
				"          STATUS,",
				"          DEPARTMENT,",
				"          TITLE,",
				"          EMPLOYEE_TYPE,",
				"          JOBCODE,",
				"          SUPERVISOR,",
				"          BIRTHDATE,",
				"          HIREDATE,",
				"          TERMINATIONDATE,",
				"          LOCATION,",
				"          SITE_ID,",
				"          SRC_TYPE_HASH_KEY,",
				"          NewPERSON_ID,",
				"          EFFECTIVE_DT",
				"     ),",
				"     skipDuplicateMapInputs: true,",
				"     skipDuplicateMapOutputs: true) ~> selPersonInsert",
				"selPersonInsert alterRow(insertIf(1==1)) ~> alterRowInsert",
				"selPersonUpdate derive(EFFECTIVE_DT = currentTimestamp()) ~> dcPersonUpdate",
				"splitPerson@UpdateItem select(mapColumn(",
				"          PERSON_FIRST_NM,",
				"          PERSON_NBR,",
				"          PERSON_LAST_NM,",
				"          STATUS,",
				"          DEPARTMENT,",
				"          TITLE,",
				"          EMPLOYEE_TYPE,",
				"          JOBCODE,",
				"          SUPERVISOR,",
				"          BIRTHDATE,",
				"          HIREDATE,",
				"          TERMINATIONDATE,",
				"          LOCATION,",
				"          STATUSDATE,",
				"          SITE_ID,",
				"          SRC_TYPE_HASH_KEY,",
				"          ExistPERSON_ID,",
				"          ExistPERSON_NBR",
				"     ),",
				"     skipDuplicateMapInputs: true,",
				"     skipDuplicateMapOutputs: true) ~> selPersonUpdate",
				"dcPersonUpdate alterRow(updateIf(1==1)) ~> alterRowUpdate",
				"alterRowInsert sink(allowSchemaDrift: true,",
				"     validateSchema: false,",
				"     input(",
				"          PERSON_ID as integer,",
				"          PERSON_NBR as string,",
				"          PERSON_FIRST_NM as string,",
				"          PERSON_LAST_NM as string,",
				"          STATUS as string,",
				"          DEPARTMENT as string,",
				"          TITLE as string,",
				"          EMPLOYEE_TYPE as string,",
				"          JOBCODE as string,",
				"          SUPERVISOR as string,",
				"          BIRTHDATE as date,",
				"          HIREDATE as date,",
				"          TERMINATIONDATE as date,",
				"          LOCATION as string,",
				"          SITE_ID as integer,",
				"          EFFECTIVE_DT as timestamp,",
				"          SRC_TYPE_HASH_KEY as string",
				"     ),",
				"     deletable:false,",
				"     insertable:true,",
				"     updateable:false,",
				"     upsertable:false,",
				"     format: 'table',",
				"     staged: true,",
				"     allowCopyCommand: true,",
				"     skipDuplicateMapInputs: true,",
				"     skipDuplicateMapOutputs: true,",
				"     saveOrder: 2,",
				"     errorHandlingOption: 'stopOnFirstError',",
				"     mapColumn(",
				"          PERSON_NBR,",
				"          PERSON_FIRST_NM,",
				"          PERSON_LAST_NM,",
				"          STATUS,",
				"          DEPARTMENT,",
				"          TITLE,",
				"          EMPLOYEE_TYPE,",
				"          JOBCODE,",
				"          SUPERVISOR,",
				"          BIRTHDATE,",
				"          HIREDATE,",
				"          TERMINATIONDATE,",
				"          LOCATION,",
				"          SITE_ID,",
				"          EFFECTIVE_DT,",
				"          PERSON_ID = NewPERSON_ID,",
				"          SRC_TYPE_HASH_KEY",
				"     )) ~> sinkPersonLd",
				"alterRowUpdate sink(allowSchemaDrift: true,",
				"     validateSchema: false,",
				"     input(",
				"          PERSON_ID as integer,",
				"          PERSON_NBR as string,",
				"          PERSON_FIRST_NM as string,",
				"          PERSON_LAST_NM as string,",
				"          STATUS as string,",
				"          DEPARTMENT as string,",
				"          TITLE as string,",
				"          EMPLOYEE_TYPE as string,",
				"          JOBCODE as string,",
				"          SUPERVISOR as string,",
				"          BIRTHDATE as date,",
				"          HIREDATE as date,",
				"          TERMINATIONDATE as date,",
				"          LOCATION as string,",
				"          SITE_ID as integer,",
				"          EFFECTIVE_DT as timestamp,",
				"          SRC_TYPE_HASH_KEY as string",
				"     ),",
				"     deletable:false,",
				"     insertable:false,",
				"     updateable:true,",
				"     upsertable:false,",
				"     keys:['PERSON_NBR','SITE_ID'],",
				"     format: 'table',",
				"     staged: true,",
				"     allowCopyCommand: true,",
				"     skipDuplicateMapInputs: true,",
				"     skipDuplicateMapOutputs: true,",
				"     saveOrder: 1,",
				"     errorHandlingOption: 'stopOnFirstError',",
				"     mapColumn(",
				"          PERSON_ID = ExistPERSON_ID,",
				"          PERSON_NBR = ExistPERSON_NBR,",
				"          PERSON_FIRST_NM,",
				"          PERSON_LAST_NM,",
				"          STATUS,",
				"          DEPARTMENT,",
				"          TITLE,",
				"          EMPLOYEE_TYPE,",
				"          JOBCODE,",
				"          SUPERVISOR,",
				"          BIRTHDATE,",
				"          HIREDATE,",
				"          TERMINATIONDATE,",
				"          LOCATION,",
				"          SITE_ID,",
				"          EFFECTIVE_DT,",
				"          SRC_TYPE_HASH_KEY",
				"     )) ~> sinkPersonUpdate"
			]
		}
	}
}