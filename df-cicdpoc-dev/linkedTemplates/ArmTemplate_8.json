{
	"$schema": "http://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
	"contentVersion": "1.0.0.0",
	"parameters": {
		"factoryName": {
			"type": "string",
			"metadata": "Data Factory name",
			"defaultValue": "df-cicdpoc-dev"
		}
	},
	"variables": {
		"factoryId": "[concat('Microsoft.DataFactory/factories/', parameters('factoryName'))]"
	},
	"resources": [
		{
			"name": "[concat(parameters('factoryName'), '/dpRawStgWoStatus_df')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "srcRawStgWoStatus_ds",
								"type": "DatasetReference"
							},
							"name": "srcRawStgWoStatus"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "AzureSynpMXMSTGWoStatus",
								"type": "DatasetReference"
							},
							"name": "sinkRawStgWoStatus"
						}
					],
					"transformations": [
						{
							"name": "dCRawStgWoStatus"
						}
					],
					"scriptLines": [
						"source(output(",
						"          WONUM as string,",
						"          PARENT as string,",
						"          STATUS as string,",
						"          CHANGEDATE as string,",
						"          CHANGEBY as string,",
						"          ORGID as string,",
						"          SITEID as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     purgeFiles: true) ~> srcRawStgWoStatus",
						"srcRawStgWoStatus derive(ENTRY_DT = currentTimestamp(),",
						"          STATUS = iifNull(STATUS, 'NA', STATUS),",
						"          CHANGEDATE = iifNull(toTimestamp(substring(CHANGEDATE, 1, 23), 'yyyy-MM-dd HH:mm:ss.SSS'), toTimestamp('1900-01-01 00:00:00','yyyy-MM-dd HH:mm:ss'), toTimestamp(substring(CHANGEDATE, 1, 23), 'yyyy-MM-dd HH:mm:ss.SSS')),",
						"          CHANGEBY = iifNull(CHANGEBY, 'NA', CHANGEBY),",
						"          ORGID = iifNull(ORGID, 'NA', ORGID),",
						"          SITEID = iifNull(SITEID, 'NA', SITEID)) ~> dCRawStgWoStatus",
						"dCRawStgWoStatus sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          WONUM as string,",
						"          PARENT as string,",
						"          STATUS as string,",
						"          CHANGEDATE as timestamp,",
						"          CHANGEBY as string,",
						"          ORGID as string,",
						"          SITEID as string,",
						"          ENTRY_DT as timestamp",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     truncate:true,",
						"     format: 'table',",
						"     staged: true,",
						"     allowCopyCommand: true,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          WONUM,",
						"          PARENT,",
						"          STATUS,",
						"          CHANGEDATE,",
						"          CHANGEBY,",
						"          ORGID,",
						"          SITEID,",
						"          ENTRY_DT",
						"     )) ~> sinkRawStgWoStatus"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/dpRawStgWoStatus_df1')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "srcRawStgWoStatus_ds1",
								"type": "DatasetReference"
							},
							"name": "srcRawStgWoStatus"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "AzureSynpMXMSTGWoStatus1",
								"type": "DatasetReference"
							},
							"name": "sinkRawStgWoStatus"
						}
					],
					"transformations": [
						{
							"name": "dCRawStgWoStatus"
						}
					],
					"scriptLines": [
						"source(output(",
						"          WONUM as string,",
						"          PARENT as string,",
						"          STATUS as string,",
						"          CHANGEDATE as string,",
						"          CHANGEBY as string,",
						"          ORGID as string,",
						"          SITEID as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     purgeFiles: true) ~> srcRawStgWoStatus",
						"srcRawStgWoStatus derive(ENTRY_DT = currentTimestamp(),",
						"          STATUS = iifNull(STATUS, 'NA', STATUS),",
						"          CHANGEDATE = iifNull(toTimestamp(substring(CHANGEDATE, 1, 23), 'yyyy-MM-dd HH:mm:ss.SSS'), toTimestamp('1900-01-01 00:00:00','yyyy-MM-dd HH:mm:ss'), toTimestamp(substring(CHANGEDATE, 1, 23), 'yyyy-MM-dd HH:mm:ss.SSS')),",
						"          CHANGEBY = iifNull(CHANGEBY, 'NA', CHANGEBY),",
						"          ORGID = iifNull(ORGID, 'NA', ORGID),",
						"          SITEID = iifNull(SITEID, 'NA', SITEID)) ~> dCRawStgWoStatus",
						"dCRawStgWoStatus sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          WONUM as string,",
						"          PARENT as string,",
						"          STATUS as string,",
						"          CHANGEDATE as timestamp,",
						"          CHANGEBY as string,",
						"          ORGID as string,",
						"          SITEID as string,",
						"          ENTRY_DT as timestamp",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     truncate:true,",
						"     format: 'table',",
						"     staged: true,",
						"     allowCopyCommand: true,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          WONUM,",
						"          PARENT,",
						"          STATUS,",
						"          CHANGEDATE,",
						"          CHANGEBY,",
						"          ORGID,",
						"          SITEID,",
						"          ENTRY_DT",
						"     )) ~> sinkRawStgWoStatus"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/dpRawStgWorkOrder_df')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "RawStgWorkOrder_ds1",
								"type": "DatasetReference"
							},
							"name": "srcRawStgWorkOrder"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "AzureSynpMXMSTGWorkOrder1",
								"type": "DatasetReference"
							},
							"name": "sinkRawStgWorkOrder",
							"rejectedDataLinkedService": {
								"referenceName": "AzureDataLakeStorage1",
								"type": "LinkedServiceReference"
							}
						}
					],
					"transformations": [
						{
							"name": "dCRawStgWorkOrder"
						}
					],
					"scriptLines": [
						"source(output(",
						"          WONUM as string,",
						"          PARENT as string,",
						"          GOVTWONUM as string,",
						"          JPNUM as string,",
						"          ASSETNUM as string,",
						"          ORGID as string,",
						"          SITEID as string,",
						"          LOCATION as string,",
						"          STATUS as string,",
						"          WORKTYPE as string,",
						"          TASKID as string,",
						"          ISTASK as string,",
						"          DESCRIPTION as string,",
						"          PLUSCJPREVNUM as string,",
						"          WOPRIORITY as string,",
						"          CHANGEDATE as string,",
						"          STATUSDATE as string,",
						"          CHANGEBY as string,",
						"          PMDUEDATE as string,",
						"          TARGSTARTDATE as string,",
						"          TARGCOMPDATE as string,",
						"          REPORTDATE as string,",
						"          RESPONDBY as string,",
						"          ESTDUR as string,",
						"          ACTLABHRS as string,",
						"          ACTSTART as string,",
						"          ACTFINISH as string,",
						"          ACTINTLABHRS as string,",
						"          WOGROUP as string,",
						"          PERSONGROUP as string,",
						"          OWNERGROUP as string,",
						"          PLUSCFREQUENCY as string,",
						"          PLUSCFREQUNIT as string,",
						"          PMNEXTDUEDATE as string,",
						"          PMNUM as string,",
						"          WORKORDERID as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     inferDriftedColumnTypes: true,",
						"     ignoreNoFilesFound: false,",
						"     purgeFiles: true) ~> srcRawStgWorkOrder",
						"srcRawStgWorkOrder derive(ENTRY_DT = currentTimestamp(),",
						"          ORGID = iifNull(ORGID, 'NA', ORGID),",
						"          SITEID = iifNull(SITEID, 'NA', SITEID),",
						"          LOCATION = iifNull(LOCATION, 'NA', LOCATION),",
						"          JPNUM = iifNull(JPNUM, 'NA', JPNUM),",
						"          ASSETNUM = iifNull(ASSETNUM, 'NA', ASSETNUM),",
						"          STATUS = iifNull(STATUS, 'NA', STATUS),",
						"          WORKTYPE = iifNull(WORKTYPE, 'NA', WORKTYPE),",
						"          TASKID = iifNull(toInteger(TASKID), toInteger(-1), toInteger(TASKID)),",
						"          ISTASK = iifNull(toInteger(ISTASK), toInteger(-1), toInteger(ISTASK)),",
						"          DESCRIPTION = iifNull(DESCRIPTION, 'NA', DESCRIPTION),",
						"          WOPRIORITY = iifNull(toInteger(WOPRIORITY), toInteger(0), toInteger(WOPRIORITY)),",
						"          CHANGEDATE = iifNull(toTimestamp(substring(CHANGEDATE, 1, 23), 'yyyy-MM-dd HH:mm:ss.SSS'), toTimestamp('1900-01-01 00:00:00','yyyy-MM-dd HH:mm:ss'), toTimestamp(substring(CHANGEDATE, 1, 23), 'yyyy-MM-dd HH:mm:ss.SSS')),",
						"          STATUSDATE = iifNull(toTimestamp(substring(STATUSDATE, 1, 23), 'yyyy-MM-dd HH:mm:ss.SSS'), toTimestamp('1900-01-01 00:00:00','yyyy-MM-dd HH:mm:ss'), toTimestamp(substring(STATUSDATE, 1, 23), 'yyyy-MM-dd HH:mm:ss.SSS')),",
						"          CHANGEBY = iifNull(CHANGEBY, 'NA', CHANGEBY),",
						"          REPORTDATE = iifNull(toTimestamp(substring(REPORTDATE, 1, 23), 'yyyy-MM-dd HH:mm:ss.SSS'), toTimestamp('1900-01-01 00:00:00','yyyy-MM-dd HH:mm:ss'), toTimestamp(substring(REPORTDATE, 1, 23), 'yyyy-MM-dd HH:mm:ss.SSS')),",
						"          RESPONDBY = iifNull(toTimestamp(substring(RESPONDBY, 1, 23), 'yyyy-MM-dd HH:mm:ss.SSS'), toTimestamp('1900-01-01 00:00:00','yyyy-MM-dd HH:mm:ss'), toTimestamp(substring(RESPONDBY, 1, 23), 'yyyy-MM-dd HH:mm:ss.SSS')),",
						"          ACTLABHRS = iifNull(toDecimal(ACTLABHRS), toDecimal(00.000), toDecimal(ACTLABHRS)),",
						"          ACTSTART = toTimestamp(substring(ACTSTART, 1, 23), 'yyyy-MM-dd HH:mm:ss.SSS'),",
						"          ACTFINISH = toTimestamp(substring(ACTFINISH, 1, 23), 'yyyy-MM-dd HH:mm:ss.SSS'),",
						"          ACTINTLABHRS = iifNull(toDecimal(ACTINTLABHRS), toDecimal(00.000), toDecimal(ACTINTLABHRS)),",
						"          WOGROUP = iifNull(WOGROUP, 'NA', WOGROUP),",
						"          PERSONGROUP = iifNull(PERSONGROUP, 'NA', PERSONGROUP),",
						"          OWNERGROUP = iifNull(OWNERGROUP, 'NA', OWNERGROUP),",
						"          ESTDUR = iifNull(toDecimal(ESTDUR), toDecimal(00.000), toDecimal(ESTDUR)),",
						"          PMDUEDATE = toTimestamp(substring(PMDUEDATE, 1, 23), 'yyyy-MM-dd HH:mm:ss.SSS'),",
						"          TARGSTARTDATE = toTimestamp(substring(TARGSTARTDATE, 1, 23), 'yyyy-MM-dd HH:mm:ss.SSS'),",
						"          TARGCOMPDATE = toTimestamp(substring(TARGCOMPDATE, 1, 23), 'yyyy-MM-dd HH:mm:ss.SSS'),",
						"          PLUSCFREQUENCY = toInteger(PLUSCFREQUENCY),",
						"          PMNEXTDUEDATE = toDate(PMNEXTDUEDATE, 'yyyy-MM-dd')) ~> dCRawStgWorkOrder",
						"dCRawStgWorkOrder sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          WONUM as string,",
						"          PARENT as string,",
						"          GOVTWONUM as string,",
						"          ORGID as string,",
						"          SITEID as string,",
						"          LOCATION as string,",
						"          ASSETNUM as string,",
						"          STATUS as string,",
						"          JPNUM as string,",
						"          WORKTYPE as string,",
						"          TASKID as integer,",
						"          ISTASK as integer,",
						"          DESCRIPTION as string,",
						"          PLUSCJPREVNUM as integer,",
						"          WOPRIORITY as integer,",
						"          CHANGEDATE as timestamp,",
						"          STATUSDATE as timestamp,",
						"          CHANGEBY as string,",
						"          PMDUEDATE as date,",
						"          TARGSTARTDATE as timestamp,",
						"          TARGCOMPDATE as timestamp,",
						"          REPORTDATE as timestamp,",
						"          RESPONDBY as timestamp,",
						"          ACTLABHRS as decimal(18,9),",
						"          ACTSTART as timestamp,",
						"          ACTFINISH as timestamp,",
						"          ACTINTLABHRS as decimal(18,9),",
						"          ESTDUR as decimal(18,9),",
						"          WOGROUP as string,",
						"          PERSONGROUP as string,",
						"          OWNERGROUP as string,",
						"          PLUSCFREQUENCY as integer,",
						"          PLUSCFREQUNIT as string,",
						"          PMNEXTDUEDATE as date,",
						"          PMNUM as string,",
						"          ENTRY_DT as timestamp,",
						"          WO_ID as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     truncate:true,",
						"     format: 'table',",
						"     staged: true,",
						"     allowCopyCommand: true,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'allErrors',",
						"     outputRejectedData: true,",
						"     rejectedData_fileSystem: 'raw',",
						"     rejectedData_folderPath: 'maximo/rejects',",
						"     transactionCommit: 'single',",
						"     reportSuccessOnError: true,",
						"     mapColumn(",
						"          WONUM,",
						"          PARENT,",
						"          GOVTWONUM,",
						"          ORGID,",
						"          SITEID,",
						"          LOCATION,",
						"          JPNUM,",
						"          ASSETNUM,",
						"          STATUS,",
						"          WORKTYPE,",
						"          TASKID,",
						"          ISTASK,",
						"          DESCRIPTION,",
						"          PLUSCJPREVNUM,",
						"          WOPRIORITY,",
						"          CHANGEDATE,",
						"          STATUSDATE,",
						"          CHANGEBY,",
						"          PMDUEDATE,",
						"          TARGSTARTDATE,",
						"          TARGCOMPDATE,",
						"          REPORTDATE,",
						"          RESPONDBY,",
						"          ACTLABHRS,",
						"          ACTSTART,",
						"          ACTFINISH,",
						"          ACTINTLABHRS,",
						"          ESTDUR,",
						"          WOGROUP,",
						"          PERSONGROUP,",
						"          OWNERGROUP,",
						"          PLUSCFREQUENCY,",
						"          PLUSCFREQUNIT,",
						"          PMNEXTDUEDATE,",
						"          PMNUM,",
						"          ENTRY_DT,",
						"          WO_ID = WORKORDERID",
						"     )) ~> sinkRawStgWorkOrder"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/dpRawStgWorkOrder_df1')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "RawStgWorkOrder_ds11",
								"type": "DatasetReference"
							},
							"name": "srcRawStgWorkOrder"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "AzureSynpMXMSTGWorkOrder11",
								"type": "DatasetReference"
							},
							"name": "sinkRawStgWorkOrder",
							"rejectedDataLinkedService": {
								"referenceName": "AzureDataLakeStorage1",
								"type": "LinkedServiceReference"
							}
						}
					],
					"transformations": [
						{
							"name": "dCRawStgWorkOrder"
						}
					],
					"scriptLines": [
						"source(output(",
						"          WONUM as string,",
						"          PARENT as string,",
						"          GOVTWONUM as string,",
						"          JPNUM as string,",
						"          ASSETNUM as string,",
						"          ORGID as string,",
						"          SITEID as string,",
						"          LOCATION as string,",
						"          STATUS as string,",
						"          WORKTYPE as string,",
						"          TASKID as string,",
						"          ISTASK as string,",
						"          DESCRIPTION as string,",
						"          PLUSCJPREVNUM as string,",
						"          WOPRIORITY as string,",
						"          CHANGEDATE as string,",
						"          STATUSDATE as string,",
						"          CHANGEBY as string,",
						"          PMDUEDATE as string,",
						"          TARGSTARTDATE as string,",
						"          TARGCOMPDATE as string,",
						"          REPORTDATE as string,",
						"          RESPONDBY as string,",
						"          ESTDUR as string,",
						"          ACTLABHRS as string,",
						"          ACTSTART as string,",
						"          ACTFINISH as string,",
						"          ACTINTLABHRS as string,",
						"          WOGROUP as string,",
						"          PERSONGROUP as string,",
						"          OWNERGROUP as string,",
						"          PLUSCFREQUENCY as string,",
						"          PLUSCFREQUNIT as string,",
						"          PMNEXTDUEDATE as string,",
						"          PMNUM as string,",
						"          WORKORDERID as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     inferDriftedColumnTypes: true,",
						"     ignoreNoFilesFound: false,",
						"     purgeFiles: true) ~> srcRawStgWorkOrder",
						"srcRawStgWorkOrder derive(ENTRY_DT = currentTimestamp(),",
						"          ORGID = iifNull(ORGID, 'NA', ORGID),",
						"          SITEID = iifNull(SITEID, 'NA', SITEID),",
						"          LOCATION = iifNull(LOCATION, 'NA', LOCATION),",
						"          JPNUM = iifNull(JPNUM, 'NA', JPNUM),",
						"          ASSETNUM = iifNull(ASSETNUM, 'NA', ASSETNUM),",
						"          STATUS = iifNull(STATUS, 'NA', STATUS),",
						"          WORKTYPE = iifNull(WORKTYPE, 'NA', WORKTYPE),",
						"          TASKID = iifNull(toInteger(TASKID), toInteger(-1), toInteger(TASKID)),",
						"          ISTASK = iifNull(toInteger(ISTASK), toInteger(-1), toInteger(ISTASK)),",
						"          DESCRIPTION = iifNull(DESCRIPTION, 'NA', DESCRIPTION),",
						"          WOPRIORITY = iifNull(toInteger(WOPRIORITY), toInteger(0), toInteger(WOPRIORITY)),",
						"          CHANGEDATE = iifNull(toTimestamp(substring(CHANGEDATE, 1, 23), 'yyyy-MM-dd HH:mm:ss.SSS'), toTimestamp('1900-01-01 00:00:00','yyyy-MM-dd HH:mm:ss'), toTimestamp(substring(CHANGEDATE, 1, 23), 'yyyy-MM-dd HH:mm:ss.SSS')),",
						"          STATUSDATE = iifNull(toTimestamp(substring(STATUSDATE, 1, 23), 'yyyy-MM-dd HH:mm:ss.SSS'), toTimestamp('1900-01-01 00:00:00','yyyy-MM-dd HH:mm:ss'), toTimestamp(substring(STATUSDATE, 1, 23), 'yyyy-MM-dd HH:mm:ss.SSS')),",
						"          CHANGEBY = iifNull(CHANGEBY, 'NA', CHANGEBY),",
						"          REPORTDATE = iifNull(toTimestamp(substring(REPORTDATE, 1, 23), 'yyyy-MM-dd HH:mm:ss.SSS'), toTimestamp('1900-01-01 00:00:00','yyyy-MM-dd HH:mm:ss'), toTimestamp(substring(REPORTDATE, 1, 23), 'yyyy-MM-dd HH:mm:ss.SSS')),",
						"          RESPONDBY = iifNull(toTimestamp(substring(RESPONDBY, 1, 23), 'yyyy-MM-dd HH:mm:ss.SSS'), toTimestamp('1900-01-01 00:00:00','yyyy-MM-dd HH:mm:ss'), toTimestamp(substring(RESPONDBY, 1, 23), 'yyyy-MM-dd HH:mm:ss.SSS')),",
						"          ACTLABHRS = iifNull(toDecimal(ACTLABHRS), toDecimal(00.000), toDecimal(ACTLABHRS)),",
						"          ACTSTART = toTimestamp(substring(ACTSTART, 1, 23), 'yyyy-MM-dd HH:mm:ss.SSS'),",
						"          ACTFINISH = toTimestamp(substring(ACTFINISH, 1, 23), 'yyyy-MM-dd HH:mm:ss.SSS'),",
						"          ACTINTLABHRS = iifNull(toDecimal(ACTINTLABHRS), toDecimal(00.000), toDecimal(ACTINTLABHRS)),",
						"          WOGROUP = iifNull(WOGROUP, 'NA', WOGROUP),",
						"          PERSONGROUP = iifNull(PERSONGROUP, 'NA', PERSONGROUP),",
						"          OWNERGROUP = iifNull(OWNERGROUP, 'NA', OWNERGROUP),",
						"          ESTDUR = iifNull(toDecimal(ESTDUR), toDecimal(00.000), toDecimal(ESTDUR)),",
						"          PMDUEDATE = toTimestamp(substring(PMDUEDATE, 1, 23), 'yyyy-MM-dd HH:mm:ss.SSS'),",
						"          TARGSTARTDATE = toTimestamp(substring(TARGSTARTDATE, 1, 23), 'yyyy-MM-dd HH:mm:ss.SSS'),",
						"          TARGCOMPDATE = toTimestamp(substring(TARGCOMPDATE, 1, 23), 'yyyy-MM-dd HH:mm:ss.SSS'),",
						"          PLUSCFREQUENCY = toInteger(PLUSCFREQUENCY),",
						"          PMNEXTDUEDATE = toDate(PMNEXTDUEDATE, 'yyyy-MM-dd')) ~> dCRawStgWorkOrder",
						"dCRawStgWorkOrder sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          WONUM as string,",
						"          PARENT as string,",
						"          GOVTWONUM as string,",
						"          ORGID as string,",
						"          SITEID as string,",
						"          LOCATION as string,",
						"          ASSETNUM as string,",
						"          STATUS as string,",
						"          JPNUM as string,",
						"          WORKTYPE as string,",
						"          TASKID as integer,",
						"          ISTASK as integer,",
						"          DESCRIPTION as string,",
						"          PLUSCJPREVNUM as integer,",
						"          WOPRIORITY as integer,",
						"          CHANGEDATE as timestamp,",
						"          STATUSDATE as timestamp,",
						"          CHANGEBY as string,",
						"          PMDUEDATE as date,",
						"          TARGSTARTDATE as timestamp,",
						"          TARGCOMPDATE as timestamp,",
						"          REPORTDATE as timestamp,",
						"          RESPONDBY as timestamp,",
						"          ACTLABHRS as decimal(18,9),",
						"          ACTSTART as timestamp,",
						"          ACTFINISH as timestamp,",
						"          ACTINTLABHRS as decimal(18,9),",
						"          ESTDUR as decimal(18,9),",
						"          WOGROUP as string,",
						"          PERSONGROUP as string,",
						"          OWNERGROUP as string,",
						"          PLUSCFREQUENCY as integer,",
						"          PLUSCFREQUNIT as string,",
						"          PMNEXTDUEDATE as date,",
						"          PMNUM as string,",
						"          ENTRY_DT as timestamp,",
						"          WO_ID as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     truncate:true,",
						"     format: 'table',",
						"     staged: true,",
						"     allowCopyCommand: true,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'allErrors',",
						"     outputRejectedData: true,",
						"     rejectedData_fileSystem: 'raw',",
						"     rejectedData_folderPath: 'maximo/rejects',",
						"     transactionCommit: 'single',",
						"     reportSuccessOnError: true,",
						"     mapColumn(",
						"          WONUM,",
						"          PARENT,",
						"          GOVTWONUM,",
						"          ORGID,",
						"          SITEID,",
						"          LOCATION,",
						"          JPNUM,",
						"          ASSETNUM,",
						"          STATUS,",
						"          WORKTYPE,",
						"          TASKID,",
						"          ISTASK,",
						"          DESCRIPTION,",
						"          PLUSCJPREVNUM,",
						"          WOPRIORITY,",
						"          CHANGEDATE,",
						"          STATUSDATE,",
						"          CHANGEBY,",
						"          PMDUEDATE,",
						"          TARGSTARTDATE,",
						"          TARGCOMPDATE,",
						"          REPORTDATE,",
						"          RESPONDBY,",
						"          ACTLABHRS,",
						"          ACTSTART,",
						"          ACTFINISH,",
						"          ACTINTLABHRS,",
						"          ESTDUR,",
						"          WOGROUP,",
						"          PERSONGROUP,",
						"          OWNERGROUP,",
						"          PLUSCFREQUENCY,",
						"          PLUSCFREQUNIT,",
						"          PMNEXTDUEDATE,",
						"          PMNUM,",
						"          ENTRY_DT,",
						"          WO_ID = WORKORDERID",
						"     )) ~> sinkRawStgWorkOrder"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/dp_Asset_Dim_df')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "SrcAzureSynpMxmAsset",
								"type": "DatasetReference"
							},
							"name": "SrcstgAssetRead"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd",
								"type": "DatasetReference"
							},
							"name": "srcAssetSiteRefRd"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd",
								"type": "DatasetReference"
							},
							"name": "AssetExistingRowsRd"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd",
								"type": "DatasetReference"
							},
							"name": "MaxKey"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "SinkAssetInitialLoad",
								"type": "DatasetReference"
							},
							"name": "sinkAssetLd",
							"rejectedDataLinkedService": {
								"referenceName": "AzureDataLakeStorage1",
								"type": "LinkedServiceReference"
							}
						},
						{
							"dataset": {
								"referenceName": "SinkAssetInitialLoad",
								"type": "DatasetReference"
							},
							"name": "sinkAssetUpdate"
						}
					],
					"transformations": [
						{
							"name": "skAsset"
						},
						{
							"name": "lkpAssetSite"
						},
						{
							"name": "AssetExistingRows"
						},
						{
							"name": "dcAssetHashKey"
						},
						{
							"name": "existsAsset"
						},
						{
							"name": "lookupExistAsset"
						},
						{
							"name": "ConditionalSplitAsset"
						},
						{
							"name": "joinAssetMaxKey"
						},
						{
							"name": "dcSK"
						},
						{
							"name": "selASSETInsert"
						},
						{
							"name": "alterRowAssetInsert"
						},
						{
							"name": "selAssetUpdate"
						},
						{
							"name": "dcAssetUpdate"
						},
						{
							"name": "alterRowAssetUpdate"
						}
					],
					"scriptLines": [
						"source(output(",
						"          ASSETNUM as string,",
						"          ASSETTAG as string,",
						"          LOCATION as string,",
						"          SITEID as string,",
						"          ORGID as string,",
						"          ASSET_DESCRIPTION as string,",
						"          INSTALL_DATE as date",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT ASSETNUM,ASSETTAG,LOCATION,SITEID,ORGID,DESCRIPTION AS ASSET_DESCRIPTION,INSTALLDATE AS INSTALL_DATE\\nFROM MXMSTG.STG_ASSET',",
						"     format: 'query',",
						"     staged: true,",
						"     partitionBy('hash', 1)) ~> SrcstgAssetRead",
						"source(output(",
						"          ORGANIZATION_ID as integer,",
						"          SITE_ID as integer,",
						"          ORGANIZATION_NM as string,",
						"          SITE_NM as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT O.ORGANIZATION_ID AS ORGANIZATION_ID,S.SITE_ID AS SITE_ID ,O.ORGANIZATION_NM,S.SITE_NM\\nFROM\\nMXMDW.ORGANIZATION O,\\nMXMDW.SITE S\\nWHERE\\nS.ORGANIZATION_ID=O.ORGANIZATION_ID\\n',",
						"     format: 'query',",
						"     staged: true) ~> srcAssetSiteRefRd",
						"source(output(",
						"          ASSET_ID as integer,",
						"          ASSETNUM as string,",
						"          SITE_ID as integer,",
						"          ASSETTAG as string,",
						"          LOCATION as string,",
						"          INSTALL_DATE as date,",
						"          ASSET_DESCRIPTION as string,",
						"          SRC_TYPE_HASH_KEY as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT ASSET_ID,ASSETNUM,SITE_ID,ASSETTAG,LOCATION,INSTALL_DATE,ASSET_DESCRIPTION,SRC_TYPE_HASH_KEY FROM MXMDW.ASSET',",
						"     format: 'query',",
						"     staged: true) ~> AssetExistingRowsRd",
						"source(output(",
						"          MAXKEY as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT MAXKEY=ISNULL(MAX(ASSET_ID),0) FROM  MXMDW.ASSET',",
						"     format: 'query',",
						"     staged: true) ~> MaxKey",
						"joinAssetMaxKey keyGenerate(output(NewASSET_ID as long),",
						"     startAt: 1L,",
						"     stepValue: 1L,",
						"     partitionBy('hash', 1)) ~> skAsset",
						"SrcstgAssetRead, srcAssetSiteRefRd lookup(SITEID == SITE_NM",
						"     && ORGID == ORGANIZATION_NM,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     partitionBy('hash', 1),",
						"     broadcast: 'auto')~> lkpAssetSite",
						"AssetExistingRowsRd select(mapColumn(",
						"          ExistASSET_ID = ASSET_ID,",
						"          ExistASSETNUM = ASSETNUM,",
						"          ExistSITE_ID = SITE_ID,",
						"          ExistASSETTAG = ASSETTAG,",
						"          ExistLOCATION = LOCATION,",
						"          ExistASSET_DESCRIPTION = ASSET_DESCRIPTION,",
						"          ExistINSTALL_DATE = INSTALL_DATE,",
						"          ExistSRC_TYPE_HASH_KEY = SRC_TYPE_HASH_KEY",
						"     ),",
						"     partitionBy('hash', 1),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> AssetExistingRows",
						"lkpAssetSite derive(SRC_TYPE_HASH_KEY = sha2(256,ASSETNUM,SITE_ID,ASSETTAG,LOCATION,INSTALL_DATE),",
						"     partitionBy('hash', 1)) ~> dcAssetHashKey",
						"dcAssetHashKey, AssetExistingRows exists(ASSETNUM == ExistASSETNUM",
						"     && SITE_ID == ExistSITE_ID",
						"     && ASSETTAG == ExistASSETTAG",
						"     && LOCATION == ExistLOCATION",
						"     && ASSET_DESCRIPTION == ExistASSET_DESCRIPTION",
						"     && INSTALL_DATE == ExistINSTALL_DATE",
						"     && SRC_TYPE_HASH_KEY == ExistSRC_TYPE_HASH_KEY,",
						"     negate:true,",
						"     partitionBy('hash', 1),",
						"     broadcast: 'right')~> existsAsset",
						"existsAsset, AssetExistingRows lookup(ASSETNUM == ExistASSETNUM",
						"     && SITE_ID == ExistSITE_ID,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     partitionBy('hash', 1),",
						"     broadcast: 'auto')~> lookupExistAsset",
						"lookupExistAsset split(isNull(ExistASSET_ID),",
						"     disjoint: false,",
						"     partitionBy('hash', 1)) ~> ConditionalSplitAsset@(NewItem, UpdateItem)",
						"ConditionalSplitAsset@NewItem, MaxKey join(1==1,",
						"     joinType:'cross',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     partitionBy('hash', 1),",
						"     broadcast: 'auto')~> joinAssetMaxKey",
						"skAsset derive(NewASSET_ID = NewASSET_ID+ MAXKEY,",
						"          EFFECTIVE_DT = currentTimestamp()) ~> dcSK",
						"dcSK select(mapColumn(",
						"          ASSETNUM,",
						"          ASSETTAG,",
						"          LOCATION,",
						"          SITE_ID,",
						"          ASSET_DESCRIPTION,",
						"          INSTALL_DATE,",
						"          SRC_TYPE_HASH_KEY,",
						"          EFFECTIVE_DT,",
						"          NewASSET_ID",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selASSETInsert",
						"selASSETInsert alterRow(insertIf(1==1),",
						"     partitionBy('hash', 1)) ~> alterRowAssetInsert",
						"ConditionalSplitAsset@UpdateItem select(mapColumn(",
						"          ASSETNUM,",
						"          ASSETTAG,",
						"          LOCATION,",
						"          SITE_ID,",
						"          ASSET_DESCRIPTION,",
						"          INSTALL_DATE,",
						"          SRC_TYPE_HASH_KEY,",
						"          ExistASSET_ID,",
						"          ExistASSETNUM,",
						"          ExistSITE_ID",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selAssetUpdate",
						"selAssetUpdate derive(EFFECTIVE_DT = currentTimestamp(),",
						"     partitionBy('hash', 1)) ~> dcAssetUpdate",
						"dcAssetUpdate alterRow(updateIf(1==1),",
						"     partitionBy('hash', 1)) ~> alterRowAssetUpdate",
						"alterRowAssetInsert sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          ASSET_ID as integer,",
						"          ASSETNUM as string,",
						"          ASSETTAG as string,",
						"          SITE_ID as integer,",
						"          LOCATION as string,",
						"          ASSET_DESCRIPTION as string,",
						"          INSTALL_DATE as date,",
						"          EFFECTIVE_DT as timestamp,",
						"          SRC_TYPE_HASH_KEY as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     staged: true,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     saveOrder: 2,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     outputRejectedData: true,",
						"     rejectedData_fileSystem: 'rawzone',",
						"     mapColumn(",
						"          ASSET_ID = NewASSET_ID,",
						"          ASSETNUM,",
						"          ASSETTAG,",
						"          SITE_ID,",
						"          LOCATION,",
						"          ASSET_DESCRIPTION,",
						"          INSTALL_DATE,",
						"          EFFECTIVE_DT,",
						"          SRC_TYPE_HASH_KEY",
						"     )) ~> sinkAssetLd",
						"alterRowAssetUpdate sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          ASSET_ID as integer,",
						"          ASSETNUM as string,",
						"          ASSETTAG as string,",
						"          SITE_ID as integer,",
						"          LOCATION as string,",
						"          ASSET_DESCRIPTION as string,",
						"          INSTALL_DATE as date,",
						"          EFFECTIVE_DT as timestamp,",
						"          SRC_TYPE_HASH_KEY as string",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['ASSETNUM','SITE_ID'],",
						"     format: 'table',",
						"     staged: true,",
						"     allowCopyCommand: true,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     saveOrder: 1,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          ASSETNUM = ExistASSETNUM,",
						"          ASSETTAG,",
						"          SITE_ID = ExistSITE_ID,",
						"          LOCATION,",
						"          ASSET_DESCRIPTION,",
						"          INSTALL_DATE,",
						"          EFFECTIVE_DT,",
						"          SRC_TYPE_HASH_KEY",
						"     )) ~> sinkAssetUpdate"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/dp_Asset_Dim_df1')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "SrcAzureSynpMxmAsset1",
								"type": "DatasetReference"
							},
							"name": "SrcstgAssetRead"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd7",
								"type": "DatasetReference"
							},
							"name": "srcAssetSiteRefRd"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd7",
								"type": "DatasetReference"
							},
							"name": "AssetExistingRowsRd"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd7",
								"type": "DatasetReference"
							},
							"name": "MaxKey"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "SinkAssetInitialLoad1",
								"type": "DatasetReference"
							},
							"name": "sinkAssetLd",
							"rejectedDataLinkedService": {
								"referenceName": "AzureDataLakeStorage1",
								"type": "LinkedServiceReference"
							}
						},
						{
							"dataset": {
								"referenceName": "SinkAssetInitialLoad1",
								"type": "DatasetReference"
							},
							"name": "sinkAssetUpdate"
						}
					],
					"transformations": [
						{
							"name": "skAsset"
						},
						{
							"name": "lkpAssetSite"
						},
						{
							"name": "AssetExistingRows"
						},
						{
							"name": "dcAssetHashKey"
						},
						{
							"name": "existsAsset"
						},
						{
							"name": "lookupExistAsset"
						},
						{
							"name": "ConditionalSplitAsset"
						},
						{
							"name": "joinAssetMaxKey"
						},
						{
							"name": "dcSK"
						},
						{
							"name": "selASSETInsert"
						},
						{
							"name": "alterRowAssetInsert"
						},
						{
							"name": "selAssetUpdate"
						},
						{
							"name": "dcAssetUpdate"
						},
						{
							"name": "alterRowAssetUpdate"
						}
					],
					"scriptLines": [
						"source(output(",
						"          ASSETNUM as string,",
						"          ASSETTAG as string,",
						"          LOCATION as string,",
						"          SITEID as string,",
						"          ORGID as string,",
						"          ASSET_DESCRIPTION as string,",
						"          INSTALL_DATE as date",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT ASSETNUM,ASSETTAG,LOCATION,SITEID,ORGID,DESCRIPTION AS ASSET_DESCRIPTION,INSTALLDATE AS INSTALL_DATE\\nFROM MXMSTG.STG_ASSET',",
						"     format: 'query',",
						"     staged: true,",
						"     partitionBy('hash', 1)) ~> SrcstgAssetRead",
						"source(output(",
						"          ORGANIZATION_ID as integer,",
						"          SITE_ID as integer,",
						"          ORGANIZATION_NM as string,",
						"          SITE_NM as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT O.ORGANIZATION_ID AS ORGANIZATION_ID,S.SITE_ID AS SITE_ID ,O.ORGANIZATION_NM,S.SITE_NM\\nFROM\\nMXMDW.ORGANIZATION O,\\nMXMDW.SITE S\\nWHERE\\nS.ORGANIZATION_ID=O.ORGANIZATION_ID\\n',",
						"     format: 'query',",
						"     staged: true) ~> srcAssetSiteRefRd",
						"source(output(",
						"          ASSET_ID as integer,",
						"          ASSETNUM as string,",
						"          SITE_ID as integer,",
						"          ASSETTAG as string,",
						"          LOCATION as string,",
						"          INSTALL_DATE as date,",
						"          ASSET_DESCRIPTION as string,",
						"          SRC_TYPE_HASH_KEY as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT ASSET_ID,ASSETNUM,SITE_ID,ASSETTAG,LOCATION,INSTALL_DATE,ASSET_DESCRIPTION,SRC_TYPE_HASH_KEY FROM MXMDW.ASSET',",
						"     format: 'query',",
						"     staged: true) ~> AssetExistingRowsRd",
						"source(output(",
						"          MAXKEY as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT MAXKEY=ISNULL(MAX(ASSET_ID),0) FROM  MXMDW.ASSET',",
						"     format: 'query',",
						"     staged: true) ~> MaxKey",
						"joinAssetMaxKey keyGenerate(output(NewASSET_ID as long),",
						"     startAt: 1L,",
						"     stepValue: 1L,",
						"     partitionBy('hash', 1)) ~> skAsset",
						"SrcstgAssetRead, srcAssetSiteRefRd lookup(SITEID == SITE_NM",
						"     && ORGID == ORGANIZATION_NM,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     partitionBy('hash', 1),",
						"     broadcast: 'auto')~> lkpAssetSite",
						"AssetExistingRowsRd select(mapColumn(",
						"          ExistASSET_ID = ASSET_ID,",
						"          ExistASSETNUM = ASSETNUM,",
						"          ExistSITE_ID = SITE_ID,",
						"          ExistASSETTAG = ASSETTAG,",
						"          ExistLOCATION = LOCATION,",
						"          ExistASSET_DESCRIPTION = ASSET_DESCRIPTION,",
						"          ExistINSTALL_DATE = INSTALL_DATE,",
						"          ExistSRC_TYPE_HASH_KEY = SRC_TYPE_HASH_KEY",
						"     ),",
						"     partitionBy('hash', 1),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> AssetExistingRows",
						"lkpAssetSite derive(SRC_TYPE_HASH_KEY = sha2(256,ASSETNUM,SITE_ID,ASSETTAG,LOCATION,INSTALL_DATE),",
						"     partitionBy('hash', 1)) ~> dcAssetHashKey",
						"dcAssetHashKey, AssetExistingRows exists(ASSETNUM == ExistASSETNUM",
						"     && SITE_ID == ExistSITE_ID",
						"     && ASSETTAG == ExistASSETTAG",
						"     && LOCATION == ExistLOCATION",
						"     && ASSET_DESCRIPTION == ExistASSET_DESCRIPTION",
						"     && INSTALL_DATE == ExistINSTALL_DATE",
						"     && SRC_TYPE_HASH_KEY == ExistSRC_TYPE_HASH_KEY,",
						"     negate:true,",
						"     partitionBy('hash', 1),",
						"     broadcast: 'right')~> existsAsset",
						"existsAsset, AssetExistingRows lookup(ASSETNUM == ExistASSETNUM",
						"     && SITE_ID == ExistSITE_ID,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     partitionBy('hash', 1),",
						"     broadcast: 'auto')~> lookupExistAsset",
						"lookupExistAsset split(isNull(ExistASSET_ID),",
						"     disjoint: false,",
						"     partitionBy('hash', 1)) ~> ConditionalSplitAsset@(NewItem, UpdateItem)",
						"ConditionalSplitAsset@NewItem, MaxKey join(1==1,",
						"     joinType:'cross',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     partitionBy('hash', 1),",
						"     broadcast: 'auto')~> joinAssetMaxKey",
						"skAsset derive(NewASSET_ID = NewASSET_ID+ MAXKEY,",
						"          EFFECTIVE_DT = currentTimestamp()) ~> dcSK",
						"dcSK select(mapColumn(",
						"          ASSETNUM,",
						"          ASSETTAG,",
						"          LOCATION,",
						"          SITE_ID,",
						"          ASSET_DESCRIPTION,",
						"          INSTALL_DATE,",
						"          SRC_TYPE_HASH_KEY,",
						"          EFFECTIVE_DT,",
						"          NewASSET_ID",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selASSETInsert",
						"selASSETInsert alterRow(insertIf(1==1),",
						"     partitionBy('hash', 1)) ~> alterRowAssetInsert",
						"ConditionalSplitAsset@UpdateItem select(mapColumn(",
						"          ASSETNUM,",
						"          ASSETTAG,",
						"          LOCATION,",
						"          SITE_ID,",
						"          ASSET_DESCRIPTION,",
						"          INSTALL_DATE,",
						"          SRC_TYPE_HASH_KEY,",
						"          ExistASSET_ID,",
						"          ExistASSETNUM,",
						"          ExistSITE_ID",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selAssetUpdate",
						"selAssetUpdate derive(EFFECTIVE_DT = currentTimestamp(),",
						"     partitionBy('hash', 1)) ~> dcAssetUpdate",
						"dcAssetUpdate alterRow(updateIf(1==1),",
						"     partitionBy('hash', 1)) ~> alterRowAssetUpdate",
						"alterRowAssetInsert sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          ASSET_ID as integer,",
						"          ASSETNUM as string,",
						"          ASSETTAG as string,",
						"          SITE_ID as integer,",
						"          LOCATION as string,",
						"          ASSET_DESCRIPTION as string,",
						"          INSTALL_DATE as date,",
						"          EFFECTIVE_DT as timestamp,",
						"          SRC_TYPE_HASH_KEY as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     staged: true,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     saveOrder: 2,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     outputRejectedData: true,",
						"     rejectedData_fileSystem: 'rawzone',",
						"     mapColumn(",
						"          ASSET_ID = NewASSET_ID,",
						"          ASSETNUM,",
						"          ASSETTAG,",
						"          SITE_ID,",
						"          LOCATION,",
						"          ASSET_DESCRIPTION,",
						"          INSTALL_DATE,",
						"          EFFECTIVE_DT,",
						"          SRC_TYPE_HASH_KEY",
						"     )) ~> sinkAssetLd",
						"alterRowAssetUpdate sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          ASSET_ID as integer,",
						"          ASSETNUM as string,",
						"          ASSETTAG as string,",
						"          SITE_ID as integer,",
						"          LOCATION as string,",
						"          ASSET_DESCRIPTION as string,",
						"          INSTALL_DATE as date,",
						"          EFFECTIVE_DT as timestamp,",
						"          SRC_TYPE_HASH_KEY as string",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['ASSETNUM','SITE_ID'],",
						"     format: 'table',",
						"     staged: true,",
						"     allowCopyCommand: true,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     saveOrder: 1,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          ASSETNUM = ExistASSETNUM,",
						"          ASSETTAG,",
						"          SITE_ID = ExistSITE_ID,",
						"          LOCATION,",
						"          ASSET_DESCRIPTION,",
						"          INSTALL_DATE,",
						"          EFFECTIVE_DT,",
						"          SRC_TYPE_HASH_KEY",
						"     )) ~> sinkAssetUpdate"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/dp_Jobplan_Dim_df2')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "AzureSynpMxmStgRefnAsset2",
								"type": "DatasetReference"
							},
							"name": "srcJobPlanRead"
						},
						{
							"dataset": {
								"referenceName": "AzSnpMXMSTGAsset2",
								"type": "DatasetReference"
							},
							"name": "RefOrgJP"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd4",
								"type": "DatasetReference"
							},
							"name": "JobplanExistingRowRd"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd4",
								"type": "DatasetReference"
							},
							"name": "MaxKey"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "SinkJobPlanInitialLoad2",
								"type": "DatasetReference"
							},
							"name": "sinkJPInitLd"
						},
						{
							"dataset": {
								"referenceName": "SinkJobPlanInitialLoad2",
								"type": "DatasetReference"
							},
							"name": "sinkJobPlanUpdate"
						}
					],
					"transformations": [
						{
							"name": "lkpJobPlanOrgSite"
						},
						{
							"name": "selJobPlanInsert"
						},
						{
							"name": "selJobplanExistRows"
						},
						{
							"name": "existsJobPlan"
						},
						{
							"name": "lkpJobPlanExistRow"
						},
						{
							"name": "splitJobPlan"
						},
						{
							"name": "joinJobPlanMaxKey"
						},
						{
							"name": "surrogateKeyJobPlan"
						},
						{
							"name": "dcJobPlanInsert"
						},
						{
							"name": "alterRowJobPlanInsert"
						},
						{
							"name": "selJobPlanUpdate"
						},
						{
							"name": "dcJobPlanUpdate"
						},
						{
							"name": "alterRowJobPlanUpdate"
						},
						{
							"name": "dcNewHashKey"
						}
					],
					"scriptLines": [
						"source(output(",
						"          JP_NUM as string,",
						"          JP_DESC as string,",
						"          JPDURATION as decimal(10,3),",
						"          STATUS as string,",
						"          PRIORITY as integer,",
						"          JOBPLANID as integer,",
						"          DOWNTIME as integer,",
						"          LABORCODE as string,",
						"          PLUSCREVNUM as integer,",
						"          SITEID as string,",
						"          ORGID as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT JPNUM AS JP_NUM,DESCRIPTION AS JP_DESC,JPDURATION,STATUS,PRIORITY,JOBPLANID,\\nDOWNTIME,LABORCODE,PLUSCREVNUM,SITEID,ORGID FROM MXMSTG.STG_JOBPLAN',",
						"     format: 'query',",
						"     staged: true,",
						"     partitionBy('hash', 1)) ~> srcJobPlanRead",
						"source(output(",
						"          ORGANIZATION_ID as integer,",
						"          SITE_ID as integer,",
						"          ORGANIZATION_NM as string,",
						"          SITE_NM as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT O.ORGANIZATION_ID,S.SITE_ID,O.ORGANIZATION_NM,S.SITE_NM\\nFROM\\nMXMDW.ORGANIZATION O,\\nMXMDW.SITE S\\nWHERE\\nS.ORGANIZATION_ID=O.ORGANIZATION_ID',",
						"     format: 'query',",
						"     staged: true) ~> RefOrgJP",
						"source(output(",
						"          JP_ID as integer,",
						"          JOBPLANID as integer,",
						"          JP_NUM as string,",
						"          JP_DESC as string,",
						"          JPDURATION as decimal(10,3),",
						"          STATUS as string,",
						"          PRIORITY as integer,",
						"          LABORCODE as string,",
						"          PLUSCREVNUM as short,",
						"          SRC_TYPE_HASH_KEY as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT JP_ID,JOBPLANID,JP_NUM,JP_DESC,JPDURATION,STATUS,PRIORITY,LABORCODE,PLUSCREVNUM,SRC_TYPE_HASH_KEY FROM MXMDW.JOBPLAN',",
						"     format: 'query',",
						"     staged: true,",
						"     partitionBy('hash', 1)) ~> JobplanExistingRowRd",
						"source(output(",
						"          MAXKEY as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT MAXKEY=ISNULL(MAX(JP_ID),0) FROM MXMDW.JOBPLAN',",
						"     format: 'query',",
						"     staged: true,",
						"     partitionBy('hash', 1)) ~> MaxKey",
						"srcJobPlanRead, RefOrgJP lookup(ORGID == ORGANIZATION_NM",
						"     && SITEID == SITE_NM,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     partitionBy('hash', 1),",
						"     broadcast: 'auto')~> lkpJobPlanOrgSite",
						"dcJobPlanInsert select(mapColumn(",
						"          JP_NUM,",
						"          JP_DESC,",
						"          JPDURATION,",
						"          STATUS,",
						"          PRIORITY,",
						"          JOBPLANID,",
						"          DOWNTIME,",
						"          LABORCODE,",
						"          PLUSCREVNUM,",
						"          EFFECTIVE_DT,",
						"          ORGANIZATION_ID,",
						"          SITE_ID,",
						"          NewJP_ID,",
						"          SRC_TYPE_HASH_KEY",
						"     ),",
						"     partitionBy('hash', 1),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selJobPlanInsert",
						"JobplanExistingRowRd select(mapColumn(",
						"          ExistJP_ID = JP_ID,",
						"          ExistJOBPLANID = JOBPLANID,",
						"          ExistJP_NUM = JP_NUM,",
						"          ExistSRC_TYPE_HASH_KEY = SRC_TYPE_HASH_KEY",
						"     ),",
						"     partitionBy('hash', 1),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selJobplanExistRows",
						"dcNewHashKey, selJobplanExistRows exists(JOBPLANID == ExistJOBPLANID",
						"     && JP_NUM == ExistJP_NUM,",
						"     negate:true,",
						"     partitionBy('hash', 1),",
						"     broadcast: 'right')~> existsJobPlan",
						"existsJobPlan, selJobplanExistRows lookup(JOBPLANID == ExistJOBPLANID,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     partitionBy('hash', 1),",
						"     broadcast: 'auto')~> lkpJobPlanExistRow",
						"lkpJobPlanExistRow split(isNull(ExistJP_ID),",
						"     disjoint: false,",
						"     partitionBy('hash', 1)) ~> splitJobPlan@(NewItem, UpdateItem)",
						"splitJobPlan@NewItem, MaxKey join(1==1,",
						"     joinType:'cross',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     partitionBy('hash', 1),",
						"     broadcast: 'auto')~> joinJobPlanMaxKey",
						"joinJobPlanMaxKey keyGenerate(output(NewJP_ID as long),",
						"     startAt: 1L,",
						"     stepValue: 1L,",
						"     partitionBy('hash', 1)) ~> surrogateKeyJobPlan",
						"surrogateKeyJobPlan derive(NewJP_ID = NewJP_ID + MAXKEY,",
						"          EFFECTIVE_DT = currentTimestamp(),",
						"     partitionBy('hash', 1)) ~> dcJobPlanInsert",
						"selJobPlanInsert alterRow(insertIf(1==1),",
						"     partitionBy('hash', 1)) ~> alterRowJobPlanInsert",
						"splitJobPlan@UpdateItem select(mapColumn(",
						"          JP_NUM,",
						"          JP_DESC,",
						"          JPDURATION,",
						"          STATUS,",
						"          PRIORITY,",
						"          JOBPLANID,",
						"          DOWNTIME,",
						"          LABORCODE,",
						"          PLUSCREVNUM,",
						"          SITEID,",
						"          ORGID,",
						"          SRC_TYPE_HASH_KEY,",
						"          ORGANIZATION_ID,",
						"          SITE_ID,",
						"          ExistJP_ID,",
						"          ExistJOBPLANID",
						"     ),",
						"     partitionBy('hash', 1),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selJobPlanUpdate",
						"selJobPlanUpdate derive(EFFECTIVE_DT = currentTimestamp()) ~> dcJobPlanUpdate",
						"dcJobPlanUpdate alterRow(updateIf(1==1),",
						"     partitionBy('hash', 1)) ~> alterRowJobPlanUpdate",
						"lkpJobPlanOrgSite derive(SRC_TYPE_HASH_KEY = sha2(256,JOBPLANID)) ~> dcNewHashKey",
						"alterRowJobPlanInsert sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          JP_ID as integer,",
						"          JP_NUM as string,",
						"          JP_DESC as string,",
						"          JPDURATION as decimal(10,3),",
						"          STATUS as string,",
						"          PRIORITY as integer,",
						"          JOBPLANID as integer,",
						"          DOWNTIME as integer,",
						"          LABORCODE as string,",
						"          PLUSCREVNUM as integer,",
						"          ORGANIZATION_ID as integer,",
						"          SITE_ID as integer,",
						"          EFFECTIVE_DT as timestamp,",
						"          SRC_TYPE_HASH_KEY as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     staged: true,",
						"     allowCopyCommand: true,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          JP_NUM,",
						"          JP_DESC,",
						"          JPDURATION,",
						"          STATUS,",
						"          PRIORITY,",
						"          JOBPLANID,",
						"          DOWNTIME,",
						"          LABORCODE,",
						"          PLUSCREVNUM,",
						"          EFFECTIVE_DT,",
						"          ORGANIZATION_ID,",
						"          SITE_ID,",
						"          JP_ID = NewJP_ID,",
						"          SRC_TYPE_HASH_KEY",
						"     )) ~> sinkJPInitLd",
						"alterRowJobPlanUpdate sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          JP_ID as integer,",
						"          JP_NUM as string,",
						"          JP_DESC as string,",
						"          JPDURATION as decimal(10,3),",
						"          STATUS as string,",
						"          PRIORITY as integer,",
						"          JOBPLANID as integer,",
						"          DOWNTIME as integer,",
						"          LABORCODE as string,",
						"          PLUSCREVNUM as integer,",
						"          ORGANIZATION_ID as integer,",
						"          SITE_ID as integer,",
						"          EFFECTIVE_DT as timestamp,",
						"          SRC_TYPE_HASH_KEY as string",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['JOBPLANID'],",
						"     format: 'table',",
						"     staged: true,",
						"     allowCopyCommand: true,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          JOBPLANID = ExistJOBPLANID,",
						"          JP_NUM,",
						"          JP_DESC,",
						"          JPDURATION,",
						"          STATUS,",
						"          PRIORITY,",
						"          DOWNTIME,",
						"          LABORCODE,",
						"          PLUSCREVNUM,",
						"          ORGANIZATION_ID,",
						"          SITE_ID,",
						"          EFFECTIVE_DT,",
						"          SRC_TYPE_HASH_KEY",
						"     )) ~> sinkJobPlanUpdate"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/dp_Jobplan_Dim_df21')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "AzureSynpMxmStgRefnAsset21",
								"type": "DatasetReference"
							},
							"name": "srcJobPlanRead"
						},
						{
							"dataset": {
								"referenceName": "AzSnpMXMSTGAsset21",
								"type": "DatasetReference"
							},
							"name": "RefOrgJP"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd41",
								"type": "DatasetReference"
							},
							"name": "JobplanExistingRowRd"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd41",
								"type": "DatasetReference"
							},
							"name": "MaxKey"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "SinkJobPlanInitialLoad21",
								"type": "DatasetReference"
							},
							"name": "sinkJPInitLd"
						},
						{
							"dataset": {
								"referenceName": "SinkJobPlanInitialLoad21",
								"type": "DatasetReference"
							},
							"name": "sinkJobPlanUpdate"
						}
					],
					"transformations": [
						{
							"name": "lkpJobPlanOrgSite"
						},
						{
							"name": "selJobPlanInsert"
						},
						{
							"name": "selJobplanExistRows"
						},
						{
							"name": "existsJobPlan"
						},
						{
							"name": "lkpJobPlanExistRow"
						},
						{
							"name": "splitJobPlan"
						},
						{
							"name": "joinJobPlanMaxKey"
						},
						{
							"name": "surrogateKeyJobPlan"
						},
						{
							"name": "dcJobPlanInsert"
						},
						{
							"name": "alterRowJobPlanInsert"
						},
						{
							"name": "selJobPlanUpdate"
						},
						{
							"name": "dcJobPlanUpdate"
						},
						{
							"name": "alterRowJobPlanUpdate"
						},
						{
							"name": "dcNewHashKey"
						}
					],
					"scriptLines": [
						"source(output(",
						"          JP_NUM as string,",
						"          JP_DESC as string,",
						"          JPDURATION as decimal(10,3),",
						"          STATUS as string,",
						"          PRIORITY as integer,",
						"          JOBPLANID as integer,",
						"          DOWNTIME as integer,",
						"          LABORCODE as string,",
						"          PLUSCREVNUM as integer,",
						"          SITEID as string,",
						"          ORGID as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT JPNUM AS JP_NUM,DESCRIPTION AS JP_DESC,JPDURATION,STATUS,PRIORITY,JOBPLANID,\\nDOWNTIME,LABORCODE,PLUSCREVNUM,SITEID,ORGID FROM MXMSTG.STG_JOBPLAN',",
						"     format: 'query',",
						"     staged: true,",
						"     partitionBy('hash', 1)) ~> srcJobPlanRead",
						"source(output(",
						"          ORGANIZATION_ID as integer,",
						"          SITE_ID as integer,",
						"          ORGANIZATION_NM as string,",
						"          SITE_NM as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT O.ORGANIZATION_ID,S.SITE_ID,O.ORGANIZATION_NM,S.SITE_NM\\nFROM\\nMXMDW.ORGANIZATION O,\\nMXMDW.SITE S\\nWHERE\\nS.ORGANIZATION_ID=O.ORGANIZATION_ID',",
						"     format: 'query',",
						"     staged: true) ~> RefOrgJP",
						"source(output(",
						"          JP_ID as integer,",
						"          JOBPLANID as integer,",
						"          JP_NUM as string,",
						"          JP_DESC as string,",
						"          JPDURATION as decimal(10,3),",
						"          STATUS as string,",
						"          PRIORITY as integer,",
						"          LABORCODE as string,",
						"          PLUSCREVNUM as short,",
						"          SRC_TYPE_HASH_KEY as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT JP_ID,JOBPLANID,JP_NUM,JP_DESC,JPDURATION,STATUS,PRIORITY,LABORCODE,PLUSCREVNUM,SRC_TYPE_HASH_KEY FROM MXMDW.JOBPLAN',",
						"     format: 'query',",
						"     staged: true,",
						"     partitionBy('hash', 1)) ~> JobplanExistingRowRd",
						"source(output(",
						"          MAXKEY as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT MAXKEY=ISNULL(MAX(JP_ID),0) FROM MXMDW.JOBPLAN',",
						"     format: 'query',",
						"     staged: true,",
						"     partitionBy('hash', 1)) ~> MaxKey",
						"srcJobPlanRead, RefOrgJP lookup(ORGID == ORGANIZATION_NM",
						"     && SITEID == SITE_NM,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     partitionBy('hash', 1),",
						"     broadcast: 'auto')~> lkpJobPlanOrgSite",
						"dcJobPlanInsert select(mapColumn(",
						"          JP_NUM,",
						"          JP_DESC,",
						"          JPDURATION,",
						"          STATUS,",
						"          PRIORITY,",
						"          JOBPLANID,",
						"          DOWNTIME,",
						"          LABORCODE,",
						"          PLUSCREVNUM,",
						"          EFFECTIVE_DT,",
						"          ORGANIZATION_ID,",
						"          SITE_ID,",
						"          NewJP_ID,",
						"          SRC_TYPE_HASH_KEY",
						"     ),",
						"     partitionBy('hash', 1),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selJobPlanInsert",
						"JobplanExistingRowRd select(mapColumn(",
						"          ExistJP_ID = JP_ID,",
						"          ExistJOBPLANID = JOBPLANID,",
						"          ExistJP_NUM = JP_NUM,",
						"          ExistSRC_TYPE_HASH_KEY = SRC_TYPE_HASH_KEY",
						"     ),",
						"     partitionBy('hash', 1),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selJobplanExistRows",
						"dcNewHashKey, selJobplanExistRows exists(JOBPLANID == ExistJOBPLANID",
						"     && JP_NUM == ExistJP_NUM,",
						"     negate:true,",
						"     partitionBy('hash', 1),",
						"     broadcast: 'right')~> existsJobPlan",
						"existsJobPlan, selJobplanExistRows lookup(JOBPLANID == ExistJOBPLANID,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     partitionBy('hash', 1),",
						"     broadcast: 'auto')~> lkpJobPlanExistRow",
						"lkpJobPlanExistRow split(isNull(ExistJP_ID),",
						"     disjoint: false,",
						"     partitionBy('hash', 1)) ~> splitJobPlan@(NewItem, UpdateItem)",
						"splitJobPlan@NewItem, MaxKey join(1==1,",
						"     joinType:'cross',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     partitionBy('hash', 1),",
						"     broadcast: 'auto')~> joinJobPlanMaxKey",
						"joinJobPlanMaxKey keyGenerate(output(NewJP_ID as long),",
						"     startAt: 1L,",
						"     stepValue: 1L,",
						"     partitionBy('hash', 1)) ~> surrogateKeyJobPlan",
						"surrogateKeyJobPlan derive(NewJP_ID = NewJP_ID + MAXKEY,",
						"          EFFECTIVE_DT = currentTimestamp(),",
						"     partitionBy('hash', 1)) ~> dcJobPlanInsert",
						"selJobPlanInsert alterRow(insertIf(1==1),",
						"     partitionBy('hash', 1)) ~> alterRowJobPlanInsert",
						"splitJobPlan@UpdateItem select(mapColumn(",
						"          JP_NUM,",
						"          JP_DESC,",
						"          JPDURATION,",
						"          STATUS,",
						"          PRIORITY,",
						"          JOBPLANID,",
						"          DOWNTIME,",
						"          LABORCODE,",
						"          PLUSCREVNUM,",
						"          SITEID,",
						"          ORGID,",
						"          SRC_TYPE_HASH_KEY,",
						"          ORGANIZATION_ID,",
						"          SITE_ID,",
						"          ExistJP_ID,",
						"          ExistJOBPLANID",
						"     ),",
						"     partitionBy('hash', 1),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selJobPlanUpdate",
						"selJobPlanUpdate derive(EFFECTIVE_DT = currentTimestamp()) ~> dcJobPlanUpdate",
						"dcJobPlanUpdate alterRow(updateIf(1==1),",
						"     partitionBy('hash', 1)) ~> alterRowJobPlanUpdate",
						"lkpJobPlanOrgSite derive(SRC_TYPE_HASH_KEY = sha2(256,JOBPLANID)) ~> dcNewHashKey",
						"alterRowJobPlanInsert sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          JP_ID as integer,",
						"          JP_NUM as string,",
						"          JP_DESC as string,",
						"          JPDURATION as decimal(10,3),",
						"          STATUS as string,",
						"          PRIORITY as integer,",
						"          JOBPLANID as integer,",
						"          DOWNTIME as integer,",
						"          LABORCODE as string,",
						"          PLUSCREVNUM as integer,",
						"          ORGANIZATION_ID as integer,",
						"          SITE_ID as integer,",
						"          EFFECTIVE_DT as timestamp,",
						"          SRC_TYPE_HASH_KEY as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     staged: true,",
						"     allowCopyCommand: true,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          JP_NUM,",
						"          JP_DESC,",
						"          JPDURATION,",
						"          STATUS,",
						"          PRIORITY,",
						"          JOBPLANID,",
						"          DOWNTIME,",
						"          LABORCODE,",
						"          PLUSCREVNUM,",
						"          EFFECTIVE_DT,",
						"          ORGANIZATION_ID,",
						"          SITE_ID,",
						"          JP_ID = NewJP_ID,",
						"          SRC_TYPE_HASH_KEY",
						"     )) ~> sinkJPInitLd",
						"alterRowJobPlanUpdate sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          JP_ID as integer,",
						"          JP_NUM as string,",
						"          JP_DESC as string,",
						"          JPDURATION as decimal(10,3),",
						"          STATUS as string,",
						"          PRIORITY as integer,",
						"          JOBPLANID as integer,",
						"          DOWNTIME as integer,",
						"          LABORCODE as string,",
						"          PLUSCREVNUM as integer,",
						"          ORGANIZATION_ID as integer,",
						"          SITE_ID as integer,",
						"          EFFECTIVE_DT as timestamp,",
						"          SRC_TYPE_HASH_KEY as string",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['JOBPLANID'],",
						"     format: 'table',",
						"     staged: true,",
						"     allowCopyCommand: true,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          JOBPLANID = ExistJOBPLANID,",
						"          JP_NUM,",
						"          JP_DESC,",
						"          JPDURATION,",
						"          STATUS,",
						"          PRIORITY,",
						"          DOWNTIME,",
						"          LABORCODE,",
						"          PLUSCREVNUM,",
						"          ORGANIZATION_ID,",
						"          SITE_ID,",
						"          EFFECTIVE_DT,",
						"          SRC_TYPE_HASH_KEY",
						"     )) ~> sinkJobPlanUpdate"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/dp_Labtrans_Fact_df')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd2",
								"type": "DatasetReference"
							},
							"name": "srcStgLabtransRd"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd2",
								"type": "DatasetReference"
							},
							"name": "OrgSiteRef"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd2",
								"type": "DatasetReference"
							},
							"name": "LocationRef"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd2",
								"type": "DatasetReference"
							},
							"name": "CraftRef"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd2",
								"type": "DatasetReference"
							},
							"name": "WorkorderRef"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd2",
								"type": "DatasetReference"
							},
							"name": "MaxKey"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd2",
								"type": "DatasetReference"
							},
							"name": "ExistRows"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "SinkLabtrans",
								"type": "DatasetReference"
							},
							"name": "sinkLabtrans"
						},
						{
							"dataset": {
								"referenceName": "SinkLabtrans",
								"type": "DatasetReference"
							},
							"name": "sinkUpdateLabtrans"
						}
					],
					"transformations": [
						{
							"name": "selExistRows"
						},
						{
							"name": "lkpOrgSite"
						},
						{
							"name": "lkpLocation"
						},
						{
							"name": "lkpCraft"
						},
						{
							"name": "joinWo"
						},
						{
							"name": "existsLabTrans"
						},
						{
							"name": "lkpLabtrans"
						},
						{
							"name": "splitLabtrans"
						},
						{
							"name": "joinMaxKey"
						},
						{
							"name": "sKeyLabTrans"
						},
						{
							"name": "selLabTrans"
						},
						{
							"name": "dcInsertLabtrans"
						},
						{
							"name": "selInsertLabtrans"
						},
						{
							"name": "alterRowInsert"
						},
						{
							"name": "dcUpdateLabtrans"
						},
						{
							"name": "alterRowUpdate"
						},
						{
							"name": "dcLabtrans"
						}
					],
					"scriptLines": [
						"source(output(",
						"          WONUM as string,",
						"          SITEID as string,",
						"          ORGID as string,",
						"          LOCATION as string,",
						"          PAYRATE as decimal(18,2),",
						"          CRAFT as string,",
						"          STARTDATETIME as timestamp,",
						"          FINISHDATETIME as timestamp,",
						"          REGULARHRS as decimal(18,9),",
						"          STARTDATE as date,",
						"          FINISHDATE as date,",
						"          TRANSDATE as timestamp,",
						"          LAB_ID as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT REFWO AS WONUM,SITEID,ORGID,LOCATION,PAYRATE,CRAFT,STARTDATETIME,FINISHDATETIME,REGULARHRS,STARTDATE,FINISHDATE,TRANSDATE,LAB_ID FROM MXMSTG.STG_LABTRANS',",
						"     format: 'query',",
						"     staged: true) ~> srcStgLabtransRd",
						"source(output(",
						"          ORGANIZATION_ID as integer,",
						"          SITE_ID as integer,",
						"          ORGANIZATION_NM as string,",
						"          SITE_NM as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT O.ORGANIZATION_ID,S.SITE_ID,O.ORGANIZATION_NM,S.SITE_NM\\nFROM\\nMXMDW.ORGANIZATION O,\\nMXMDW.SITE S\\nWHERE\\nS.ORGANIZATION_ID=O.ORGANIZATION_ID',",
						"     format: 'query',",
						"     staged: true) ~> OrgSiteRef",
						"source(output(",
						"          LOCATION_ID as integer,",
						"          DIM_LOCATION as string,",
						"          LOCATION_DESC as string,",
						"          LOC_SITE_NM as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT L.LOCATION_ID AS LOCATION_ID,L.LOCATION AS DIM_LOCATION,L.DESCRIPTION AS LOCATION_DESC, S.SITE_NM AS LOC_SITE_NM\\nFROM MXMDW.LOCATIONS L\\nINNER JOIN MXMDW.SITE S\\nON S.SITE_ID = L.SITE_ID',",
						"     format: 'query',",
						"     staged: true) ~> LocationRef",
						"source(output(",
						"          CRAFT_ID as integer,",
						"          CRAFT_CD as string,",
						"          ORGANIZATION_NM as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT CRAFT_ID,CRAFT_CD,ORGANIZATION_NM FROM MXMDW.CRAFT',",
						"     format: 'query',",
						"     staged: true) ~> CraftRef",
						"source(output(",
						"          WONUM as string,",
						"          SITE_ID as integer,",
						"          GOVTWONUM as string,",
						"          ASSETNUM as string,",
						"          STATUS as string,",
						"          JPNUM as string,",
						"          WORKTYPE as string,",
						"          DESCRIPTION as string,",
						"          WOPRIORITY as integer,",
						"          STATUSDATE as timestamp,",
						"          TARGCOMPDATE as timestamp,",
						"          REPORTDATE as timestamp,",
						"          PMDUEDATE as date,",
						"          TARGSTARTDATE as timestamp,",
						"          ESTDUR as decimal(18,9),",
						"          WOGROUP as string,",
						"          PERSONGROUP as string,",
						"          PMNEXTDUEDATE as date,",
						"          PMNUM as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT WONUM,SITE_ID,GOVTWONUM,ASSETNUM,STATUS,JPNUM,WORKTYPE,DESCRIPTION,\\nWOPRIORITY,STATUSDATE,TARGCOMPDATE,REPORTDATE,PMDUEDATE,TARGSTARTDATE,ESTDUR,\\nWOGROUP,PERSONGROUP,PMNEXTDUEDATE,PMNUM\\nFROM MXMDW.WORKORDER',",
						"     format: 'query',",
						"     staged: true) ~> WorkorderRef",
						"source(output(",
						"          MAXKEY as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT MAXKEY=ISNULL(MAX(LABTRANS_ID),0) FROM  MXMDW.LABTRANS',",
						"     format: 'query',",
						"     staged: true) ~> MaxKey",
						"source(output(",
						"          LABTRANS_ID as integer,",
						"          LAB_ID as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT LABTRANS_ID,LAB_ID FROM MXMDW.LABTRANS',",
						"     format: 'query',",
						"     staged: true) ~> ExistRows",
						"ExistRows select(mapColumn(",
						"          ExistLABTRANS_ID = LABTRANS_ID,",
						"          ExistLAB_ID = LAB_ID",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selExistRows",
						"srcStgLabtransRd, OrgSiteRef lookup(ORGID == ORGANIZATION_NM",
						"     && SITEID == SITE_NM,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lkpOrgSite",
						"lkpOrgSite, LocationRef lookup(LOCATION == DIM_LOCATION",
						"     && SITEID == LOC_SITE_NM,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lkpLocation",
						"lkpLocation, CraftRef lookup(CRAFT == CRAFT_CD",
						"     && ORGID == CraftRef@ORGANIZATION_NM,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lkpCraft",
						"lkpCraft, WorkorderRef join(srcStgLabtransRd@WONUM == WorkorderRef@WONUM",
						"     && OrgSiteRef@SITE_ID == WorkorderRef@SITE_ID,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     partitionBy('hash', 1),",
						"     broadcast: 'auto')~> joinWo",
						"dcLabtrans, selExistRows exists(LAB_ID == ExistLAB_ID,",
						"     negate:true,",
						"     partitionBy('hash', 1),",
						"     broadcast: 'right')~> existsLabTrans",
						"existsLabTrans, selExistRows lookup(LAB_ID == ExistLAB_ID,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     partitionBy('hash', 1),",
						"     broadcast: 'auto')~> lkpLabtrans",
						"lkpLabtrans split(isNull(ExistLABTRANS_ID),",
						"     disjoint: false) ~> splitLabtrans@(NewItem, UpdateItem)",
						"splitLabtrans@NewItem, MaxKey join(1==1,",
						"     joinType:'cross',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinMaxKey",
						"joinMaxKey keyGenerate(output(NewLABTRANS_ID as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> sKeyLabTrans",
						"joinWo select(mapColumn(",
						"          WONUM = srcStgLabtransRd@WONUM,",
						"          PAYRATE,",
						"          CRAFT,",
						"          STARTDATE,",
						"          FINISHDATE,",
						"          STARTDATETIME,",
						"          FINISHDATETIME,",
						"          REGULARHRS,",
						"          TRANSDATE,",
						"          LAB_ID,",
						"          SITE_ID = OrgSiteRef@SITE_ID,",
						"          LOCATION_ID,",
						"          CRAFT_ID,",
						"          GOVTWONUM,",
						"          ASSETNUM,",
						"          STATUS,",
						"          JPNUM,",
						"          WORKTYPE,",
						"          DESCRIPTION,",
						"          WOPRIORITY,",
						"          STATUSDATE,",
						"          TARGCOMPDATE,",
						"          REPORTDATE,",
						"          PMDUEDATE,",
						"          TARGSTARTDATE,",
						"          ESTDUR,",
						"          WOGROUP,",
						"          PERSONGROUP,",
						"          PMNEXTDUEDATE,",
						"          PMNUM",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selLabTrans",
						"sKeyLabTrans derive(LABTRANS_ID = MAXKEY + NewLABTRANS_ID,",
						"          EFFECTIVE_DT = currentTimestamp()) ~> dcInsertLabtrans",
						"dcInsertLabtrans select(mapColumn(",
						"          WONUM,",
						"          PAYRATE,",
						"          CRAFT,",
						"          STARTDATETIME,",
						"          FINISHDATETIME,",
						"          REGULARHRS,",
						"          TRANSDATE,",
						"          LAB_ID,",
						"          SITE_ID,",
						"          LOCATION_ID,",
						"          CRAFT_ID,",
						"          GOVTWONUM,",
						"          ASSETNUM,",
						"          STATUS,",
						"          JPNUM,",
						"          WORKTYPE,",
						"          DESCRIPTION,",
						"          WOPRIORITY,",
						"          STATUSDATE,",
						"          TARGCOMPDATE,",
						"          REPORTDATE,",
						"          PMDUEDATE,",
						"          TARGSTARTDATE,",
						"          ESTDUR,",
						"          WOGROUP,",
						"          PERSONGROUP,",
						"          PMNEXTDUEDATE,",
						"          PMNUM,",
						"          LABTRANS_ID,",
						"          EFFECTIVE_DT",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selInsertLabtrans",
						"selInsertLabtrans alterRow(insertIf(1==1)) ~> alterRowInsert",
						"splitLabtrans@UpdateItem derive(EFFECTIVE_DT = currentTimestamp()) ~> dcUpdateLabtrans",
						"dcUpdateLabtrans alterRow(updateIf(1==1)) ~> alterRowUpdate",
						"selLabTrans derive(STARTDATETIME = iifNull(STARTDATETIME, STARTDATE, STARTDATETIME),",
						"          FINISHDATETIME = iifNull(FINISHDATETIME, FINISHDATE, FINISHDATETIME),",
						"          LOCATION_ID = iifNull(LOCATION_ID, toInteger(-1), LOCATION_ID)) ~> dcLabtrans",
						"alterRowInsert sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          LABTRANS_ID as integer,",
						"          WONUM as string,",
						"          SITE_ID as integer,",
						"          LOCATION_ID as integer,",
						"          CRAFT_ID as integer,",
						"          LAB_ID as integer,",
						"          PAYRATE as decimal(18,2),",
						"          STARTDATETIME as timestamp,",
						"          FINISHDATETIME as timestamp,",
						"          REGULARHRS as decimal(18,9),",
						"          TRANSDATE as timestamp,",
						"          GOVTWONUM as string,",
						"          ASSETNUM as string,",
						"          STATUS as string,",
						"          JPNUM as string,",
						"          WORKTYPE as string,",
						"          DESCRIPTION as string,",
						"          WOPRIORITY as integer,",
						"          STATUSDATE as timestamp,",
						"          TARGCOMPDATE as timestamp,",
						"          REPORTDATE as timestamp,",
						"          PMDUEDATE as date,",
						"          TARGSTARTDATE as timestamp,",
						"          ESTDUR as decimal(18,9),",
						"          WOGROUP as string,",
						"          PERSONGROUP as string,",
						"          PMNEXTDUEDATE as date,",
						"          PMNUM as string,",
						"          EFFECTIVE_DT as timestamp",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     staged: true,",
						"     allowCopyCommand: true,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     saveOrder: 2,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          LABTRANS_ID,",
						"          WONUM,",
						"          SITE_ID,",
						"          LOCATION_ID,",
						"          CRAFT_ID,",
						"          LAB_ID,",
						"          PAYRATE,",
						"          STARTDATETIME,",
						"          FINISHDATETIME,",
						"          REGULARHRS,",
						"          TRANSDATE,",
						"          GOVTWONUM,",
						"          ASSETNUM,",
						"          STATUS,",
						"          JPNUM,",
						"          WORKTYPE,",
						"          DESCRIPTION,",
						"          WOPRIORITY,",
						"          STATUSDATE,",
						"          TARGCOMPDATE,",
						"          REPORTDATE,",
						"          PMDUEDATE,",
						"          TARGSTARTDATE,",
						"          ESTDUR,",
						"          WOGROUP,",
						"          PERSONGROUP,",
						"          PMNEXTDUEDATE,",
						"          PMNUM,",
						"          EFFECTIVE_DT",
						"     )) ~> sinkLabtrans",
						"alterRowUpdate sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          LABTRANS_ID as integer,",
						"          WONUM as string,",
						"          SITE_ID as integer,",
						"          LOCATION_ID as integer,",
						"          CRAFT_ID as integer,",
						"          LAB_ID as integer,",
						"          PAYRATE as decimal(18,2),",
						"          STARTDATETIME as timestamp,",
						"          FINISHDATETIME as timestamp,",
						"          REGULARHRS as decimal(18,9),",
						"          TRANSDATE as timestamp,",
						"          GOVTWONUM as string,",
						"          ASSETNUM as string,",
						"          STATUS as string,",
						"          JPNUM as string,",
						"          WORKTYPE as string,",
						"          DESCRIPTION as string,",
						"          WOPRIORITY as integer,",
						"          STATUSDATE as timestamp,",
						"          TARGCOMPDATE as timestamp,",
						"          REPORTDATE as timestamp,",
						"          PMDUEDATE as date,",
						"          TARGSTARTDATE as timestamp,",
						"          ESTDUR as decimal(18,9),",
						"          WOGROUP as string,",
						"          PERSONGROUP as string,",
						"          PMNEXTDUEDATE as date,",
						"          PMNUM as string,",
						"          EFFECTIVE_DT as timestamp",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['LAB_ID'],",
						"     format: 'table',",
						"     staged: true,",
						"     allowCopyCommand: true,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     saveOrder: 1,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          LABTRANS_ID = ExistLABTRANS_ID,",
						"          WONUM,",
						"          SITE_ID,",
						"          LOCATION_ID,",
						"          CRAFT_ID,",
						"          LAB_ID = ExistLAB_ID,",
						"          PAYRATE,",
						"          STARTDATETIME,",
						"          FINISHDATETIME,",
						"          REGULARHRS,",
						"          TRANSDATE,",
						"          GOVTWONUM,",
						"          ASSETNUM,",
						"          STATUS,",
						"          JPNUM,",
						"          WORKTYPE,",
						"          DESCRIPTION,",
						"          WOPRIORITY,",
						"          STATUSDATE,",
						"          TARGCOMPDATE,",
						"          REPORTDATE,",
						"          PMDUEDATE,",
						"          TARGSTARTDATE,",
						"          ESTDUR,",
						"          WOGROUP,",
						"          PERSONGROUP,",
						"          PMNEXTDUEDATE,",
						"          PMNUM,",
						"          EFFECTIVE_DT",
						"     )) ~> sinkUpdateLabtrans"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/dp_Labtrans_Fact_df1')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd21",
								"type": "DatasetReference"
							},
							"name": "srcStgLabtransRd"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd21",
								"type": "DatasetReference"
							},
							"name": "OrgSiteRef"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd21",
								"type": "DatasetReference"
							},
							"name": "LocationRef"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd21",
								"type": "DatasetReference"
							},
							"name": "CraftRef"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd21",
								"type": "DatasetReference"
							},
							"name": "WorkorderRef"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd21",
								"type": "DatasetReference"
							},
							"name": "MaxKey"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd21",
								"type": "DatasetReference"
							},
							"name": "ExistRows"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "SinkLabtrans1",
								"type": "DatasetReference"
							},
							"name": "sinkLabtrans"
						},
						{
							"dataset": {
								"referenceName": "SinkLabtrans1",
								"type": "DatasetReference"
							},
							"name": "sinkUpdateLabtrans"
						}
					],
					"transformations": [
						{
							"name": "selExistRows"
						},
						{
							"name": "lkpOrgSite"
						},
						{
							"name": "lkpLocation"
						},
						{
							"name": "lkpCraft"
						},
						{
							"name": "joinWo"
						},
						{
							"name": "existsLabTrans"
						},
						{
							"name": "lkpLabtrans"
						},
						{
							"name": "splitLabtrans"
						},
						{
							"name": "joinMaxKey"
						},
						{
							"name": "sKeyLabTrans"
						},
						{
							"name": "selLabTrans"
						},
						{
							"name": "dcInsertLabtrans"
						},
						{
							"name": "selInsertLabtrans"
						},
						{
							"name": "alterRowInsert"
						},
						{
							"name": "dcUpdateLabtrans"
						},
						{
							"name": "alterRowUpdate"
						},
						{
							"name": "dcLabtrans"
						}
					],
					"scriptLines": [
						"source(output(",
						"          WONUM as string,",
						"          SITEID as string,",
						"          ORGID as string,",
						"          LOCATION as string,",
						"          PAYRATE as decimal(18,2),",
						"          CRAFT as string,",
						"          STARTDATETIME as timestamp,",
						"          FINISHDATETIME as timestamp,",
						"          REGULARHRS as decimal(18,9),",
						"          STARTDATE as date,",
						"          FINISHDATE as date,",
						"          TRANSDATE as timestamp,",
						"          LAB_ID as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT REFWO AS WONUM,SITEID,ORGID,LOCATION,PAYRATE,CRAFT,STARTDATETIME,FINISHDATETIME,REGULARHRS,STARTDATE,FINISHDATE,TRANSDATE,LAB_ID FROM MXMSTG.STG_LABTRANS',",
						"     format: 'query',",
						"     staged: true) ~> srcStgLabtransRd",
						"source(output(",
						"          ORGANIZATION_ID as integer,",
						"          SITE_ID as integer,",
						"          ORGANIZATION_NM as string,",
						"          SITE_NM as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT O.ORGANIZATION_ID,S.SITE_ID,O.ORGANIZATION_NM,S.SITE_NM\\nFROM\\nMXMDW.ORGANIZATION O,\\nMXMDW.SITE S\\nWHERE\\nS.ORGANIZATION_ID=O.ORGANIZATION_ID',",
						"     format: 'query',",
						"     staged: true) ~> OrgSiteRef",
						"source(output(",
						"          LOCATION_ID as integer,",
						"          DIM_LOCATION as string,",
						"          LOCATION_DESC as string,",
						"          LOC_SITE_NM as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT L.LOCATION_ID AS LOCATION_ID,L.LOCATION AS DIM_LOCATION,L.DESCRIPTION AS LOCATION_DESC, S.SITE_NM AS LOC_SITE_NM\\nFROM MXMDW.LOCATIONS L\\nINNER JOIN MXMDW.SITE S\\nON S.SITE_ID = L.SITE_ID',",
						"     format: 'query',",
						"     staged: true) ~> LocationRef",
						"source(output(",
						"          CRAFT_ID as integer,",
						"          CRAFT_CD as string,",
						"          ORGANIZATION_NM as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT CRAFT_ID,CRAFT_CD,ORGANIZATION_NM FROM MXMDW.CRAFT',",
						"     format: 'query',",
						"     staged: true) ~> CraftRef",
						"source(output(",
						"          WONUM as string,",
						"          SITE_ID as integer,",
						"          GOVTWONUM as string,",
						"          ASSETNUM as string,",
						"          STATUS as string,",
						"          JPNUM as string,",
						"          WORKTYPE as string,",
						"          DESCRIPTION as string,",
						"          WOPRIORITY as integer,",
						"          STATUSDATE as timestamp,",
						"          TARGCOMPDATE as timestamp,",
						"          REPORTDATE as timestamp,",
						"          PMDUEDATE as date,",
						"          TARGSTARTDATE as timestamp,",
						"          ESTDUR as decimal(18,9),",
						"          WOGROUP as string,",
						"          PERSONGROUP as string,",
						"          PMNEXTDUEDATE as date,",
						"          PMNUM as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT WONUM,SITE_ID,GOVTWONUM,ASSETNUM,STATUS,JPNUM,WORKTYPE,DESCRIPTION,\\nWOPRIORITY,STATUSDATE,TARGCOMPDATE,REPORTDATE,PMDUEDATE,TARGSTARTDATE,ESTDUR,\\nWOGROUP,PERSONGROUP,PMNEXTDUEDATE,PMNUM\\nFROM MXMDW.WORKORDER',",
						"     format: 'query',",
						"     staged: true) ~> WorkorderRef",
						"source(output(",
						"          MAXKEY as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT MAXKEY=ISNULL(MAX(LABTRANS_ID),0) FROM  MXMDW.LABTRANS',",
						"     format: 'query',",
						"     staged: true) ~> MaxKey",
						"source(output(",
						"          LABTRANS_ID as integer,",
						"          LAB_ID as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT LABTRANS_ID,LAB_ID FROM MXMDW.LABTRANS',",
						"     format: 'query',",
						"     staged: true) ~> ExistRows",
						"ExistRows select(mapColumn(",
						"          ExistLABTRANS_ID = LABTRANS_ID,",
						"          ExistLAB_ID = LAB_ID",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selExistRows",
						"srcStgLabtransRd, OrgSiteRef lookup(ORGID == ORGANIZATION_NM",
						"     && SITEID == SITE_NM,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lkpOrgSite",
						"lkpOrgSite, LocationRef lookup(LOCATION == DIM_LOCATION",
						"     && SITEID == LOC_SITE_NM,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lkpLocation",
						"lkpLocation, CraftRef lookup(CRAFT == CRAFT_CD",
						"     && ORGID == CraftRef@ORGANIZATION_NM,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lkpCraft",
						"lkpCraft, WorkorderRef join(srcStgLabtransRd@WONUM == WorkorderRef@WONUM",
						"     && OrgSiteRef@SITE_ID == WorkorderRef@SITE_ID,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     partitionBy('hash', 1),",
						"     broadcast: 'auto')~> joinWo",
						"dcLabtrans, selExistRows exists(LAB_ID == ExistLAB_ID,",
						"     negate:true,",
						"     partitionBy('hash', 1),",
						"     broadcast: 'right')~> existsLabTrans",
						"existsLabTrans, selExistRows lookup(LAB_ID == ExistLAB_ID,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     partitionBy('hash', 1),",
						"     broadcast: 'auto')~> lkpLabtrans",
						"lkpLabtrans split(isNull(ExistLABTRANS_ID),",
						"     disjoint: false) ~> splitLabtrans@(NewItem, UpdateItem)",
						"splitLabtrans@NewItem, MaxKey join(1==1,",
						"     joinType:'cross',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinMaxKey",
						"joinMaxKey keyGenerate(output(NewLABTRANS_ID as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> sKeyLabTrans",
						"joinWo select(mapColumn(",
						"          WONUM = srcStgLabtransRd@WONUM,",
						"          PAYRATE,",
						"          CRAFT,",
						"          STARTDATE,",
						"          FINISHDATE,",
						"          STARTDATETIME,",
						"          FINISHDATETIME,",
						"          REGULARHRS,",
						"          TRANSDATE,",
						"          LAB_ID,",
						"          SITE_ID = OrgSiteRef@SITE_ID,",
						"          LOCATION_ID,",
						"          CRAFT_ID,",
						"          GOVTWONUM,",
						"          ASSETNUM,",
						"          STATUS,",
						"          JPNUM,",
						"          WORKTYPE,",
						"          DESCRIPTION,",
						"          WOPRIORITY,",
						"          STATUSDATE,",
						"          TARGCOMPDATE,",
						"          REPORTDATE,",
						"          PMDUEDATE,",
						"          TARGSTARTDATE,",
						"          ESTDUR,",
						"          WOGROUP,",
						"          PERSONGROUP,",
						"          PMNEXTDUEDATE,",
						"          PMNUM",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selLabTrans",
						"sKeyLabTrans derive(LABTRANS_ID = MAXKEY + NewLABTRANS_ID,",
						"          EFFECTIVE_DT = currentTimestamp()) ~> dcInsertLabtrans",
						"dcInsertLabtrans select(mapColumn(",
						"          WONUM,",
						"          PAYRATE,",
						"          CRAFT,",
						"          STARTDATETIME,",
						"          FINISHDATETIME,",
						"          REGULARHRS,",
						"          TRANSDATE,",
						"          LAB_ID,",
						"          SITE_ID,",
						"          LOCATION_ID,",
						"          CRAFT_ID,",
						"          GOVTWONUM,",
						"          ASSETNUM,",
						"          STATUS,",
						"          JPNUM,",
						"          WORKTYPE,",
						"          DESCRIPTION,",
						"          WOPRIORITY,",
						"          STATUSDATE,",
						"          TARGCOMPDATE,",
						"          REPORTDATE,",
						"          PMDUEDATE,",
						"          TARGSTARTDATE,",
						"          ESTDUR,",
						"          WOGROUP,",
						"          PERSONGROUP,",
						"          PMNEXTDUEDATE,",
						"          PMNUM,",
						"          LABTRANS_ID,",
						"          EFFECTIVE_DT",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selInsertLabtrans",
						"selInsertLabtrans alterRow(insertIf(1==1)) ~> alterRowInsert",
						"splitLabtrans@UpdateItem derive(EFFECTIVE_DT = currentTimestamp()) ~> dcUpdateLabtrans",
						"dcUpdateLabtrans alterRow(updateIf(1==1)) ~> alterRowUpdate",
						"selLabTrans derive(STARTDATETIME = iifNull(STARTDATETIME, STARTDATE, STARTDATETIME),",
						"          FINISHDATETIME = iifNull(FINISHDATETIME, FINISHDATE, FINISHDATETIME),",
						"          LOCATION_ID = iifNull(LOCATION_ID, toInteger(-1), LOCATION_ID)) ~> dcLabtrans",
						"alterRowInsert sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          LABTRANS_ID as integer,",
						"          WONUM as string,",
						"          SITE_ID as integer,",
						"          LOCATION_ID as integer,",
						"          CRAFT_ID as integer,",
						"          LAB_ID as integer,",
						"          PAYRATE as decimal(18,2),",
						"          STARTDATETIME as timestamp,",
						"          FINISHDATETIME as timestamp,",
						"          REGULARHRS as decimal(18,9),",
						"          TRANSDATE as timestamp,",
						"          GOVTWONUM as string,",
						"          ASSETNUM as string,",
						"          STATUS as string,",
						"          JPNUM as string,",
						"          WORKTYPE as string,",
						"          DESCRIPTION as string,",
						"          WOPRIORITY as integer,",
						"          STATUSDATE as timestamp,",
						"          TARGCOMPDATE as timestamp,",
						"          REPORTDATE as timestamp,",
						"          PMDUEDATE as date,",
						"          TARGSTARTDATE as timestamp,",
						"          ESTDUR as decimal(18,9),",
						"          WOGROUP as string,",
						"          PERSONGROUP as string,",
						"          PMNEXTDUEDATE as date,",
						"          PMNUM as string,",
						"          EFFECTIVE_DT as timestamp",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     staged: true,",
						"     allowCopyCommand: true,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     saveOrder: 2,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          LABTRANS_ID,",
						"          WONUM,",
						"          SITE_ID,",
						"          LOCATION_ID,",
						"          CRAFT_ID,",
						"          LAB_ID,",
						"          PAYRATE,",
						"          STARTDATETIME,",
						"          FINISHDATETIME,",
						"          REGULARHRS,",
						"          TRANSDATE,",
						"          GOVTWONUM,",
						"          ASSETNUM,",
						"          STATUS,",
						"          JPNUM,",
						"          WORKTYPE,",
						"          DESCRIPTION,",
						"          WOPRIORITY,",
						"          STATUSDATE,",
						"          TARGCOMPDATE,",
						"          REPORTDATE,",
						"          PMDUEDATE,",
						"          TARGSTARTDATE,",
						"          ESTDUR,",
						"          WOGROUP,",
						"          PERSONGROUP,",
						"          PMNEXTDUEDATE,",
						"          PMNUM,",
						"          EFFECTIVE_DT",
						"     )) ~> sinkLabtrans",
						"alterRowUpdate sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          LABTRANS_ID as integer,",
						"          WONUM as string,",
						"          SITE_ID as integer,",
						"          LOCATION_ID as integer,",
						"          CRAFT_ID as integer,",
						"          LAB_ID as integer,",
						"          PAYRATE as decimal(18,2),",
						"          STARTDATETIME as timestamp,",
						"          FINISHDATETIME as timestamp,",
						"          REGULARHRS as decimal(18,9),",
						"          TRANSDATE as timestamp,",
						"          GOVTWONUM as string,",
						"          ASSETNUM as string,",
						"          STATUS as string,",
						"          JPNUM as string,",
						"          WORKTYPE as string,",
						"          DESCRIPTION as string,",
						"          WOPRIORITY as integer,",
						"          STATUSDATE as timestamp,",
						"          TARGCOMPDATE as timestamp,",
						"          REPORTDATE as timestamp,",
						"          PMDUEDATE as date,",
						"          TARGSTARTDATE as timestamp,",
						"          ESTDUR as decimal(18,9),",
						"          WOGROUP as string,",
						"          PERSONGROUP as string,",
						"          PMNEXTDUEDATE as date,",
						"          PMNUM as string,",
						"          EFFECTIVE_DT as timestamp",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['LAB_ID'],",
						"     format: 'table',",
						"     staged: true,",
						"     allowCopyCommand: true,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     saveOrder: 1,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          LABTRANS_ID = ExistLABTRANS_ID,",
						"          WONUM,",
						"          SITE_ID,",
						"          LOCATION_ID,",
						"          CRAFT_ID,",
						"          LAB_ID = ExistLAB_ID,",
						"          PAYRATE,",
						"          STARTDATETIME,",
						"          FINISHDATETIME,",
						"          REGULARHRS,",
						"          TRANSDATE,",
						"          GOVTWONUM,",
						"          ASSETNUM,",
						"          STATUS,",
						"          JPNUM,",
						"          WORKTYPE,",
						"          DESCRIPTION,",
						"          WOPRIORITY,",
						"          STATUSDATE,",
						"          TARGCOMPDATE,",
						"          REPORTDATE,",
						"          PMDUEDATE,",
						"          TARGSTARTDATE,",
						"          ESTDUR,",
						"          WOGROUP,",
						"          PERSONGROUP,",
						"          PMNEXTDUEDATE,",
						"          PMNUM,",
						"          EFFECTIVE_DT",
						"     )) ~> sinkUpdateLabtrans"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/dp_Locations_Dim_df')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd",
								"type": "DatasetReference"
							},
							"name": "srcLocationsRead"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd",
								"type": "DatasetReference"
							},
							"name": "OrgSiteRefRead"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd",
								"type": "DatasetReference"
							},
							"name": "ExistingRecordsRead"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd",
								"type": "DatasetReference"
							},
							"name": "MaxKey"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "sinkLocationsLoad",
								"type": "DatasetReference"
							},
							"name": "sinkLocationsLoad"
						},
						{
							"dataset": {
								"referenceName": "sinkLocationsLoad",
								"type": "DatasetReference"
							},
							"name": "sinkUpdateItem"
						}
					],
					"transformations": [
						{
							"name": "selExistingRecords"
						},
						{
							"name": "lkpLocOrgSite"
						},
						{
							"name": "dcNewHashKey"
						},
						{
							"name": "existsLoc"
						},
						{
							"name": "ConsplitLoc"
						},
						{
							"name": "joinLocMaxKey"
						},
						{
							"name": "surrogateKeyLoc"
						},
						{
							"name": "dcNewItem"
						},
						{
							"name": "selNewItem"
						},
						{
							"name": "lkpExistRecords"
						},
						{
							"name": "selUpdateItem"
						},
						{
							"name": "alterRowUpdateItem"
						}
					],
					"scriptLines": [
						"source(output(",
						"          LOCATION as string,",
						"          DESCRIPTION as string,",
						"          TYPE as string,",
						"          CHANGEBY as string,",
						"          CHANGEDATE as timestamp,",
						"          STATUS as string,",
						"          STATUSDATE as timestamp,",
						"          SITEID as string,",
						"          ORGID as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT LOCATION,\\nDESCRIPTION,\\nTYPE,\\nCHANGEBY,\\nCHANGEDATE,\\nSTATUS,\\nSTATUSDATE,\\nSITEID,\\nORGID\\nFROM MXMSTG.STG_LOCATIONS',",
						"     format: 'query',",
						"     staged: true) ~> srcLocationsRead",
						"source(output(",
						"          ORGANIZATION_ID as integer,",
						"          ORGANIZATION_NM as string,",
						"          SITE_ID as integer,",
						"          SITE_NM as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT O.ORGANIZATION_ID AS ORGANIZATION_ID,O.ORGANIZATION_NM AS ORGANIZATION_NM, S.SITE_ID AS SITE_ID,S.SITE_NM AS SITE_NM\\nFROM MXMDW.ORGANIZATION O,\\nMXMDW.SITE S\\nWHERE O.ORGANIZATION_ID = S.ORGANIZATION_ID',",
						"     format: 'query',",
						"     staged: true) ~> OrgSiteRefRead",
						"source(output(",
						"          LOCATION_ID as integer,",
						"          LOCATION as string,",
						"          DESCRIPTION as string,",
						"          TYPE as string,",
						"          STATUS as string,",
						"          SITE_ID as integer,",
						"          SRC_TYPE_HASH_KEY as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT LOCATION_ID,LOCATION,DESCRIPTION,TYPE,STATUS,SITE_ID,SRC_TYPE_HASH_KEY\\nFROM MXMDW.LOCATIONS',",
						"     format: 'query',",
						"     staged: true) ~> ExistingRecordsRead",
						"source(output(",
						"          MAXKEY as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT MAXKEY=ISNULL(MAX(LOCATION_ID),0) FROM MXMDW.LOCATIONS',",
						"     format: 'query',",
						"     staged: true) ~> MaxKey",
						"ExistingRecordsRead select(mapColumn(",
						"          ExistLOCATION = LOCATION,",
						"          ExistLOCATION_ID = LOCATION_ID,",
						"          ExistSITE_ID = SITE_ID,",
						"          ExistDESCRIPTION = DESCRIPTION,",
						"          ExistTYPE = TYPE,",
						"          ExistSTATUS = STATUS,",
						"          ExistSRC_TYPE_HASH_KEY = SRC_TYPE_HASH_KEY",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selExistingRecords",
						"srcLocationsRead, OrgSiteRefRead lookup(ORGID == ORGANIZATION_NM",
						"     && SITEID == SITE_NM,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lkpLocOrgSite",
						"lkpLocOrgSite derive(SRC_TYPE_HASH_KEY = sha2(256,LOCATION,DESCRIPTION,TYPE,STATUS)) ~> dcNewHashKey",
						"dcNewHashKey, selExistingRecords exists(LOCATION == ExistLOCATION",
						"     && DESCRIPTION == ExistDESCRIPTION",
						"     && TYPE == ExistTYPE",
						"     && STATUS == ExistSTATUS",
						"     && SRC_TYPE_HASH_KEY == ExistSRC_TYPE_HASH_KEY,",
						"     negate:true,",
						"     partitionBy('hash', 1),",
						"     broadcast: 'right')~> existsLoc",
						"lkpExistRecords split(isNull(ExistLOCATION_ID),",
						"     disjoint: false,",
						"     partitionBy('hash', 1)) ~> ConsplitLoc@(NewItem, UpdateItem)",
						"ConsplitLoc@NewItem, MaxKey join(1==1,",
						"     joinType:'cross',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     partitionBy('hash', 1),",
						"     broadcast: 'auto')~> joinLocMaxKey",
						"joinLocMaxKey keyGenerate(output(MaxLOCATION_ID as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKeyLoc",
						"surrogateKeyLoc derive(EFFECTIVE_DT = currentTimestamp(),",
						"          LOCATION_ID = toInteger(MAXKEY + MaxLOCATION_ID)) ~> dcNewItem",
						"dcNewItem select(mapColumn(",
						"          LOCATION,",
						"          DESCRIPTION,",
						"          TYPE,",
						"          CHANGEBY,",
						"          CHANGEDATE,",
						"          STATUS,",
						"          STATUSDATE,",
						"          ORGANIZATION_ID,",
						"          SITE_ID,",
						"          SRC_TYPE_HASH_KEY,",
						"          EFFECTIVE_DT,",
						"          LOCATION_ID",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selNewItem",
						"existsLoc, selExistingRecords lookup(LOCATION == ExistLOCATION",
						"     && SITE_ID == ExistSITE_ID,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     partitionBy('hash', 1),",
						"     broadcast: 'auto')~> lkpExistRecords",
						"ConsplitLoc@UpdateItem select(mapColumn(",
						"          LOCATION,",
						"          SITE_ID,",
						"          DESCRIPTION,",
						"          TYPE,",
						"          CHANGEBY,",
						"          CHANGEDATE,",
						"          STATUS,",
						"          STATUSDATE,",
						"          SRC_TYPE_HASH_KEY,",
						"          ExistSRC_TYPE_HASH_KEY,",
						"          ExistLOCATION,",
						"          ExistSITE_ID",
						"     ),",
						"     partitionBy('hash', 1),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selUpdateItem",
						"selUpdateItem alterRow(updateIf(1==1)) ~> alterRowUpdateItem",
						"selNewItem sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          LOCATION_ID as integer,",
						"          LOCATION as string,",
						"          DESCRIPTION as string,",
						"          TYPE as string,",
						"          CHANGEBY as string,",
						"          CHANGEDATE as timestamp,",
						"          STATUS as string,",
						"          STATUSDATE as timestamp,",
						"          SITE_ID as integer,",
						"          ORGANIZATION_ID as integer,",
						"          EFFECTIVE_DT as timestamp,",
						"          SRC_TYPE_HASH_KEY as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     staged: true,",
						"     allowCopyCommand: true,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     saveOrder: 2,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          LOCATION_ID,",
						"          LOCATION,",
						"          DESCRIPTION,",
						"          TYPE,",
						"          CHANGEBY,",
						"          CHANGEDATE,",
						"          STATUS,",
						"          STATUSDATE,",
						"          SITE_ID,",
						"          ORGANIZATION_ID,",
						"          EFFECTIVE_DT,",
						"          SRC_TYPE_HASH_KEY",
						"     )) ~> sinkLocationsLoad",
						"alterRowUpdateItem sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          LOCATION_ID as integer,",
						"          LOCATION as string,",
						"          DESCRIPTION as string,",
						"          TYPE as string,",
						"          CHANGEBY as string,",
						"          CHANGEDATE as timestamp,",
						"          STATUS as string,",
						"          STATUSDATE as timestamp,",
						"          SITE_ID as integer,",
						"          ORGANIZATION_ID as integer,",
						"          EFFECTIVE_DT as timestamp,",
						"          SRC_TYPE_HASH_KEY as string",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['LOCATION'],",
						"     format: 'table',",
						"     staged: true,",
						"     allowCopyCommand: true,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     saveOrder: 1,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          LOCATION = ExistLOCATION,",
						"          SITE_ID = ExistSITE_ID,",
						"          DESCRIPTION,",
						"          TYPE,",
						"          CHANGEBY,",
						"          CHANGEDATE,",
						"          STATUS,",
						"          STATUSDATE,",
						"          SRC_TYPE_HASH_KEY",
						"     )) ~> sinkUpdateItem"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/dp_Locations_Dim_df1')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd7",
								"type": "DatasetReference"
							},
							"name": "srcLocationsRead"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd7",
								"type": "DatasetReference"
							},
							"name": "OrgSiteRefRead"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd7",
								"type": "DatasetReference"
							},
							"name": "ExistingRecordsRead"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd7",
								"type": "DatasetReference"
							},
							"name": "MaxKey"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "sinkLocationsLoad1",
								"type": "DatasetReference"
							},
							"name": "sinkLocationsLoad"
						},
						{
							"dataset": {
								"referenceName": "sinkLocationsLoad1",
								"type": "DatasetReference"
							},
							"name": "sinkUpdateItem"
						}
					],
					"transformations": [
						{
							"name": "selExistingRecords"
						},
						{
							"name": "lkpLocOrgSite"
						},
						{
							"name": "dcNewHashKey"
						},
						{
							"name": "existsLoc"
						},
						{
							"name": "ConsplitLoc"
						},
						{
							"name": "joinLocMaxKey"
						},
						{
							"name": "surrogateKeyLoc"
						},
						{
							"name": "dcNewItem"
						},
						{
							"name": "selNewItem"
						},
						{
							"name": "lkpExistRecords"
						},
						{
							"name": "selUpdateItem"
						},
						{
							"name": "alterRowUpdateItem"
						}
					],
					"scriptLines": [
						"source(output(",
						"          LOCATION as string,",
						"          DESCRIPTION as string,",
						"          TYPE as string,",
						"          CHANGEBY as string,",
						"          CHANGEDATE as timestamp,",
						"          STATUS as string,",
						"          STATUSDATE as timestamp,",
						"          SITEID as string,",
						"          ORGID as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT LOCATION,\\nDESCRIPTION,\\nTYPE,\\nCHANGEBY,\\nCHANGEDATE,\\nSTATUS,\\nSTATUSDATE,\\nSITEID,\\nORGID\\nFROM MXMSTG.STG_LOCATIONS',",
						"     format: 'query',",
						"     staged: true) ~> srcLocationsRead",
						"source(output(",
						"          ORGANIZATION_ID as integer,",
						"          ORGANIZATION_NM as string,",
						"          SITE_ID as integer,",
						"          SITE_NM as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT O.ORGANIZATION_ID AS ORGANIZATION_ID,O.ORGANIZATION_NM AS ORGANIZATION_NM, S.SITE_ID AS SITE_ID,S.SITE_NM AS SITE_NM\\nFROM MXMDW.ORGANIZATION O,\\nMXMDW.SITE S\\nWHERE O.ORGANIZATION_ID = S.ORGANIZATION_ID',",
						"     format: 'query',",
						"     staged: true) ~> OrgSiteRefRead",
						"source(output(",
						"          LOCATION_ID as integer,",
						"          LOCATION as string,",
						"          DESCRIPTION as string,",
						"          TYPE as string,",
						"          STATUS as string,",
						"          SITE_ID as integer,",
						"          SRC_TYPE_HASH_KEY as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT LOCATION_ID,LOCATION,DESCRIPTION,TYPE,STATUS,SITE_ID,SRC_TYPE_HASH_KEY\\nFROM MXMDW.LOCATIONS',",
						"     format: 'query',",
						"     staged: true) ~> ExistingRecordsRead",
						"source(output(",
						"          MAXKEY as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT MAXKEY=ISNULL(MAX(LOCATION_ID),0) FROM MXMDW.LOCATIONS',",
						"     format: 'query',",
						"     staged: true) ~> MaxKey",
						"ExistingRecordsRead select(mapColumn(",
						"          ExistLOCATION = LOCATION,",
						"          ExistLOCATION_ID = LOCATION_ID,",
						"          ExistSITE_ID = SITE_ID,",
						"          ExistDESCRIPTION = DESCRIPTION,",
						"          ExistTYPE = TYPE,",
						"          ExistSTATUS = STATUS,",
						"          ExistSRC_TYPE_HASH_KEY = SRC_TYPE_HASH_KEY",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selExistingRecords",
						"srcLocationsRead, OrgSiteRefRead lookup(ORGID == ORGANIZATION_NM",
						"     && SITEID == SITE_NM,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lkpLocOrgSite",
						"lkpLocOrgSite derive(SRC_TYPE_HASH_KEY = sha2(256,LOCATION,DESCRIPTION,TYPE,STATUS)) ~> dcNewHashKey",
						"dcNewHashKey, selExistingRecords exists(LOCATION == ExistLOCATION",
						"     && DESCRIPTION == ExistDESCRIPTION",
						"     && TYPE == ExistTYPE",
						"     && STATUS == ExistSTATUS",
						"     && SRC_TYPE_HASH_KEY == ExistSRC_TYPE_HASH_KEY,",
						"     negate:true,",
						"     partitionBy('hash', 1),",
						"     broadcast: 'right')~> existsLoc",
						"lkpExistRecords split(isNull(ExistLOCATION_ID),",
						"     disjoint: false,",
						"     partitionBy('hash', 1)) ~> ConsplitLoc@(NewItem, UpdateItem)",
						"ConsplitLoc@NewItem, MaxKey join(1==1,",
						"     joinType:'cross',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     partitionBy('hash', 1),",
						"     broadcast: 'auto')~> joinLocMaxKey",
						"joinLocMaxKey keyGenerate(output(MaxLOCATION_ID as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKeyLoc",
						"surrogateKeyLoc derive(EFFECTIVE_DT = currentTimestamp(),",
						"          LOCATION_ID = toInteger(MAXKEY + MaxLOCATION_ID)) ~> dcNewItem",
						"dcNewItem select(mapColumn(",
						"          LOCATION,",
						"          DESCRIPTION,",
						"          TYPE,",
						"          CHANGEBY,",
						"          CHANGEDATE,",
						"          STATUS,",
						"          STATUSDATE,",
						"          ORGANIZATION_ID,",
						"          SITE_ID,",
						"          SRC_TYPE_HASH_KEY,",
						"          EFFECTIVE_DT,",
						"          LOCATION_ID",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selNewItem",
						"existsLoc, selExistingRecords lookup(LOCATION == ExistLOCATION",
						"     && SITE_ID == ExistSITE_ID,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     partitionBy('hash', 1),",
						"     broadcast: 'auto')~> lkpExistRecords",
						"ConsplitLoc@UpdateItem select(mapColumn(",
						"          LOCATION,",
						"          SITE_ID,",
						"          DESCRIPTION,",
						"          TYPE,",
						"          CHANGEBY,",
						"          CHANGEDATE,",
						"          STATUS,",
						"          STATUSDATE,",
						"          SRC_TYPE_HASH_KEY,",
						"          ExistSRC_TYPE_HASH_KEY,",
						"          ExistLOCATION,",
						"          ExistSITE_ID",
						"     ),",
						"     partitionBy('hash', 1),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selUpdateItem",
						"selUpdateItem alterRow(updateIf(1==1)) ~> alterRowUpdateItem",
						"selNewItem sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          LOCATION_ID as integer,",
						"          LOCATION as string,",
						"          DESCRIPTION as string,",
						"          TYPE as string,",
						"          CHANGEBY as string,",
						"          CHANGEDATE as timestamp,",
						"          STATUS as string,",
						"          STATUSDATE as timestamp,",
						"          SITE_ID as integer,",
						"          ORGANIZATION_ID as integer,",
						"          EFFECTIVE_DT as timestamp,",
						"          SRC_TYPE_HASH_KEY as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     staged: true,",
						"     allowCopyCommand: true,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     saveOrder: 2,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          LOCATION_ID,",
						"          LOCATION,",
						"          DESCRIPTION,",
						"          TYPE,",
						"          CHANGEBY,",
						"          CHANGEDATE,",
						"          STATUS,",
						"          STATUSDATE,",
						"          SITE_ID,",
						"          ORGANIZATION_ID,",
						"          EFFECTIVE_DT,",
						"          SRC_TYPE_HASH_KEY",
						"     )) ~> sinkLocationsLoad",
						"alterRowUpdateItem sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          LOCATION_ID as integer,",
						"          LOCATION as string,",
						"          DESCRIPTION as string,",
						"          TYPE as string,",
						"          CHANGEBY as string,",
						"          CHANGEDATE as timestamp,",
						"          STATUS as string,",
						"          STATUSDATE as timestamp,",
						"          SITE_ID as integer,",
						"          ORGANIZATION_ID as integer,",
						"          EFFECTIVE_DT as timestamp,",
						"          SRC_TYPE_HASH_KEY as string",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['LOCATION'],",
						"     format: 'table',",
						"     staged: true,",
						"     allowCopyCommand: true,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     saveOrder: 1,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          LOCATION = ExistLOCATION,",
						"          SITE_ID = ExistSITE_ID,",
						"          DESCRIPTION,",
						"          TYPE,",
						"          CHANGEBY,",
						"          CHANGEDATE,",
						"          STATUS,",
						"          STATUSDATE,",
						"          SRC_TYPE_HASH_KEY",
						"     )) ~> sinkUpdateItem"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/dp_OperationLdFact_df')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "AzSnpMXMSTGAsset3",
								"type": "DatasetReference"
							},
							"name": "srcOperationRead"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd6",
								"type": "DatasetReference"
							},
							"name": "OrgSiteRefRd"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd6",
								"type": "DatasetReference"
							},
							"name": "AssetRefRd"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd6",
								"type": "DatasetReference"
							},
							"name": "PersonRefRd"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd6",
								"type": "DatasetReference"
							},
							"name": "JobplanRefRd"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd6",
								"type": "DatasetReference"
							},
							"name": "PerGrpRefRd"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd6",
								"type": "DatasetReference"
							},
							"name": "LocationRefRd"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd6",
								"type": "DatasetReference"
							},
							"name": "MaxKey"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd6",
								"type": "DatasetReference"
							},
							"name": "OpsExistingRows"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd6",
								"type": "DatasetReference"
							},
							"name": "srcWorkOrderReadRef"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd6",
								"type": "DatasetReference"
							},
							"name": "JobplanNullSiteRd"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "SinkOperationLd2",
								"type": "DatasetReference"
							},
							"name": "sinkOpsInsert"
						},
						{
							"dataset": {
								"referenceName": "SinkOperationLd2",
								"type": "DatasetReference"
							},
							"name": "sinkOperationUpdate"
						}
					],
					"transformations": [
						{
							"name": "srtOperation"
						},
						{
							"name": "dcOps"
						},
						{
							"name": "selOperation"
						},
						{
							"name": "lkpOrgsiteoptn"
						},
						{
							"name": "lkpAssetOptn"
						},
						{
							"name": "lkpPersonOptn"
						},
						{
							"name": "lkpJobplanOptn"
						},
						{
							"name": "lkpPerGrpOptn"
						},
						{
							"name": "lkpLocation"
						},
						{
							"name": "selOpsExistingRows"
						},
						{
							"name": "lkpExistOperation"
						},
						{
							"name": "joinMaxKey"
						},
						{
							"name": "skOperation"
						},
						{
							"name": "dcOperationInsert"
						},
						{
							"name": "alterRowOpsInsert"
						},
						{
							"name": "selectOps"
						},
						{
							"name": "lookupOpsStatusInd"
						},
						{
							"name": "selectOps2"
						},
						{
							"name": "splitOpsForUpdate"
						},
						{
							"name": "selOpsUpdate"
						},
						{
							"name": "dcOpsUpdate"
						},
						{
							"name": "alterRowUpdate"
						},
						{
							"name": "splitJobPlan"
						},
						{
							"name": "unionJobplan"
						},
						{
							"name": "selectNullJPSite"
						},
						{
							"name": "selectJPNotNullSite"
						},
						{
							"name": "lkpJPNullSite"
						}
					],
					"scriptLines": [
						"source(output(",
						"          WONUM as string,",
						"          PARENT as string,",
						"          GOVTWONUM as string,",
						"          ORGID as string,",
						"          SITEID as string,",
						"          LOCATION as string,",
						"          STATUS as string,",
						"          ASSETNUM as string,",
						"          JPNUM as string,",
						"          WO_STATUS_CHANGEDATE as timestamp,",
						"          WORKTYPE as string,",
						"          TASKID as integer,",
						"          ISTASK as integer,",
						"          DESCRIPTION as string,",
						"          PLUSCJPREVNUM as integer,",
						"          WOPRIORITY as integer,",
						"          WO_CHANGEDATE as timestamp,",
						"          STATUSDATE as timestamp,",
						"          WO_STATUS_CHANGEBY as string,",
						"          PMDUEDATE as date,",
						"          TARGSTARTDATE as timestamp,",
						"          TARGCOMPDATE as timestamp,",
						"          REPORTDATE as timestamp,",
						"          ACTLABHRS as decimal(18,9),",
						"          ACTSTART as timestamp,",
						"          ACTFINISH as timestamp,",
						"          ACTINTLABHRS as decimal(18,9),",
						"          ESTDUR as decimal(18,9),",
						"          WOGROUP as string,",
						"          PERSONGROUP as string,",
						"          OWNERGROUP as string,",
						"          PLUSCFREQUENCY as integer,",
						"          PLUSCFREQUNIT as string,",
						"          PMNEXTDUEDATE as date,",
						"          PMNUM as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     inferDriftedColumnTypes: true,",
						"     isolationLevel: 'READ_COMMITTED',",
						"     query: 'SELECT \\nWO.WONUM AS WONUM,WO.PARENT AS PARENT,GOVTWONUM,WO.ORGID,WO.SITEID,LOCATION,WS.STATUS AS STATUS,ASSETNUM,JPNUM, WS.CHANGEDATE AS WO_STATUS_CHANGEDATE,\\nWORKTYPE,TASKID,ISTASK, DESCRIPTION,PLUSCJPREVNUM,WOPRIORITY,WO.CHANGEDATE AS WO_CHANGEDATE,STATUSDATE,WS.CHANGEBY AS WO_STATUS_CHANGEBY, PMDUEDATE,\\nTARGSTARTDATE,TARGCOMPDATE,REPORTDATE,ACTLABHRS,ACTSTART, ACTFINISH,ACTINTLABHRS,ESTDUR,WOGROUP,PERSONGROUP,OWNERGROUP,PLUSCFREQUENCY,PLUSCFREQUNIT,\\nPMNEXTDUEDATE,PMNUM\\nFROM MXMSTG.STG_WORKORDER WO, MXMSTG.STG_WOSTATUS WS\\n WHERE\\n WS.WONUM=WO.WONUM\\n AND WS.ORGID=WO.ORGID\\n AND WS.SITEID=WO.SITEID',",
						"     format: 'query',",
						"     staged: true) ~> srcOperationRead",
						"source(output(",
						"          ORGANIZATION_ID as integer,",
						"          SITE_ID as integer,",
						"          ORGANIZATION_NM as string,",
						"          SITE_NM as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT O.ORGANIZATION_ID,S.SITE_ID,O.ORGANIZATION_NM,S.SITE_NM\\nFROM\\nMXMDW.ORGANIZATION O,\\nMXMDW.SITE S\\nWHERE\\nS.ORGANIZATION_ID=O.ORGANIZATION_ID',",
						"     format: 'query',",
						"     staged: true) ~> OrgSiteRefRd",
						"source(output(",
						"          ASSET_ID as integer,",
						"          ASSETNUM_ref as string,",
						"          SITE_ID_ref as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT ASSET_ID,ASSETNUM AS ASSETNUM_ref,SITE_ID AS SITE_ID_ref FROM MXMDW.ASSET',",
						"     format: 'query',",
						"     staged: true) ~> AssetRefRd",
						"source(output(",
						"          PERSON_ID as integer,",
						"          PERSON_NBR as string,",
						"          SITE_ID as integer,",
						"          ORGANIZATION_ID as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT PERSON_ID,PERSON_NBR,P.SITE_ID AS SITE_ID,S.ORGANIZATION_ID AS ORGANIZATION_ID FROM \\nMXMDW.PERSON P,\\nMXMDW.ORGANIZATION O,\\nMXMDW.SITE S\\nWHERE\\nO.ORGANIZATION_ID =S.ORGANIZATION_ID\\nAND S.SITE_ID=P.SITE_ID',",
						"     format: 'query',",
						"     staged: true) ~> PersonRefRd",
						"source(output(",
						"          JP_ID as integer,",
						"          JP_NUM as string,",
						"          JPRef_SITE_ID as integer,",
						"          JPRef_ORGANIZATION_ID as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT JP_ID,JP_NUM,SITE_ID AS JPRef_SITE_ID,ORGANIZATION_ID AS JPRef_ORGANIZATION_ID FROM MXMDW.JOBPLAN WHERE STATUS=\\'ACTIVE\\' AND SITE_ID>0',",
						"     format: 'query',",
						"     staged: true) ~> JobplanRefRd",
						"source(output(",
						"          PERSON_GROUP_ID as integer,",
						"          PERSON_GRP_CD as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT PERSON_GROUP_ID,PERSON_GRP_CD FROM MXMDW.PERSON_GROUP',",
						"     format: 'query',",
						"     staged: true) ~> PerGrpRefRd",
						"source(output(",
						"          LOCATION_ID as integer,",
						"          DIM_LOCATION as string,",
						"          LOCATION_DESC as string,",
						"          LOC_SITE_NM as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT L.LOCATION_ID AS LOCATION_ID,L.LOCATION AS DIM_LOCATION,L.DESCRIPTION AS LOCATION_DESC, S.SITE_NM AS LOC_SITE_NM\\nFROM MXMDW.LOCATIONS L\\nINNER JOIN MXMDW.SITE S\\nON S.SITE_ID = L.SITE_ID',",
						"     format: 'query',",
						"     staged: true) ~> LocationRefRd",
						"source(output(",
						"          MAXKEY as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT MAXKEY=ISNULL(MAX(OPERATION_ID),0) FROM  MXMDW.OPERATION',",
						"     format: 'query',",
						"     staged: true) ~> MaxKey",
						"source(output(",
						"          OPERATION_ID as integer,",
						"          WONUM as string,",
						"          SITE_ID as integer,",
						"          STATUS as string,",
						"          WO_STATUS_CHANGEDATE as timestamp,",
						"          SNAPSHOT_DATE as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT OPERATION_ID, WONUM,SITE_ID,STATUS,WO_STATUS_CHANGEDATE,SNAPSHOT_DATE FROM MXMDW.OPERATION WHERE CURRENT_RECORD_IND=1',",
						"     format: 'query',",
						"     staged: true,",
						"     partitionBy('hash', 1)) ~> OpsExistingRows",
						"source(output(",
						"          RefWONUM as string,",
						"          RefSITE_ID as integer,",
						"          RefSTATUS as string,",
						"          RefSTATUSDATE as timestamp,",
						"          FLAG as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT WONUM AS RefWONUM,S.SITE_ID AS RefSITE_ID,STATUS AS RefSTATUS,STATUSDATE AS RefSTATUSDATE,\\'1\\' AS FLAG FROM MXMSTG.STG_WORKORDER WO,MXMDW.SITE S\\nWHERE\\nWO.SITEID=S.SITE_NM',",
						"     format: 'query',",
						"     staged: true) ~> srcWorkOrderReadRef",
						"source(output(",
						"          JP_ID as integer,",
						"          JP_NUM as string,",
						"          JPRef_SITE_ID as integer,",
						"          JPRef_ORGANIZATION_ID as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT JP_ID,JP_NUM,SITE_ID AS JPRef_SITE_ID,ORGANIZATION_ID AS JPRef_ORGANIZATION_ID FROM MXMDW.JOBPLAN WHERE STATUS=\\'ACTIVE\\' AND SITE_ID<0',",
						"     format: 'query',",
						"     staged: true) ~> JobplanNullSiteRd",
						"srcOperationRead sort(asc(WONUM, true),",
						"     asc(PARENT, true),",
						"     asc(ORGID, true),",
						"     asc(SITEID, true),",
						"     asc(WO_STATUS_CHANGEDATE, true),",
						"     caseInsensitive: true) ~> srtOperation",
						"lookupOpsStatusInd derive(CAL_PMDUEDT = iifNull(PMDUEDATE, TARGSTARTDATE,REPORTDATE),",
						"          WORKTYPE_CM_PM = case(\r",
						"     (WORKTYPE == 'CM' || WORKTYPE == 'DMO' || WORKTYPE == 'OWO' || WORKTYPE == 'SERV'), 'CM',\r",
						"     (WORKTYPE == 'PM' || WORKTYPE == 'INSP' || WORKTYPE == 'SWM' || WORKTYPE == 'PMO'), 'PM',\r",
						"        (WORKTYPE == 'PJ' || WORKTYPE == 'PWO' ), 'PJ',\r",
						"        'OTHERS'  \r",
						"     ),",
						"          {REPORTMONTH_YEAR } = year(REPORTDATE),",
						"          REPORTDATE_MONTH = month(REPORTDATE),",
						"          REPORTDATE_CM_PM = case(     \r",
						"     (WORKTYPE == 'PM' || WORKTYPE == 'INSP' || WORKTYPE == 'SWM' || WORKTYPE == 'PMO'), iifNull(PMDUEDATE, TARGSTARTDATE,REPORTDATE),       \r",
						"        REPORTDATE  \r",
						"     ),",
						"          CURRENT_RECORD_IND = iifNull(toInteger(FLAG), 0, 1),",
						"          EFFECTIVE_DT = currentTimestamp(),",
						"          SNAPSHOT_DATE = toTimestamp(toString(WO_STATUS_CHANGEDATE, 'yyyy-MM-dd 00:00:00'),'yyyy-MM-dd HH:mm:ss'),",
						"          ASSET_ID = iifNull(ASSET_ID, toInteger(-1), ASSET_ID),",
						"          PERSON_ID = iifNull(PERSON_ID, toInteger(-1), PERSON_ID),",
						"          JP_ID = iifNull(JP_ID, toInteger(-1), JP_ID),",
						"          PERSON_GROUP_ID = iifNull(PERSON_GROUP_ID, toInteger(-1), PERSON_GROUP_ID),",
						"          LOCATION_ID = iifNull(LOCATION_ID, toInteger(-1), LOCATION_ID),",
						"          AVAILABLE_MANHOUR = toInteger(506),",
						"          PARENT_ACTLABHRS = toDecimal(0.0),",
						"          STATUS_FLAG = case(     \r",
						"     (STATUS == 'READY' || STATUS == 'CLOSE' || STATUS == 'CAN' || STATUS == 'COMP'), 2,1        \r",
						"     )) ~> dcOps",
						"joinMaxKey select(mapColumn(",
						"          WONUM,",
						"          PARENT,",
						"          GOVTWONUM,",
						"          LOCATION_ID,",
						"          STATUS,",
						"          WO_STATUS_CHANGEDATE,",
						"          WORKTYPE,",
						"          TASKID,",
						"          ISTASK,",
						"          DESCRIPTION,",
						"          PLUSCREVNUM = PLUSCJPREVNUM,",
						"          WOPRIORITY,",
						"          STATUSDATE,",
						"          WO_STATUS_CHANGEBY,",
						"          PMDUEDATE,",
						"          TARGSTARTDATE,",
						"          TARGCOMPDATE,",
						"          REPORTDATE,",
						"          WO_CHANGEDATE,",
						"          ACTLABHRS,",
						"          ACTSTART,",
						"          ACTFINISH,",
						"          ACTINTLABHRS,",
						"          WOGROUP,",
						"          CAL_PMDUEDT,",
						"          WORKTYPE_CM_PM,",
						"          {REPORTMONTH_YEAR },",
						"          REPORTDATE_MONTH,",
						"          REPORTDATE_CM_PM,",
						"          CURRENT_RECORD_IND,",
						"          EFFECTIVE_DT,",
						"          SNAPSHOT_DATE,",
						"          ORGANIZATION_ID,",
						"          SITE_ID,",
						"          LOCATION_ID,",
						"          ASSET_ID,",
						"          PERSON_ID,",
						"          JP_ID,",
						"          PERSON_GROUP_ID,",
						"          PERSON_GROUP = PERSONGROUP,",
						"          ESTDUR,",
						"          PLUSCFREQUENCY,",
						"          PLUSCFREQUNIT,",
						"          PMNEXTDUEDATE,",
						"          PMNUM,",
						"          AVAILABLE_MANHOUR,",
						"          CURRENT_RECORD_IND,",
						"          PARENT_ACTLABHRS,",
						"          MAXKEY,",
						"          STATUS_FLAG",
						"     ),",
						"     partitionBy('hash', 1),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selOperation",
						"srtOperation, OrgSiteRefRd lookup(ORGID == ORGANIZATION_NM",
						"     && SITEID == SITE_NM,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lkpOrgsiteoptn",
						"lkpLocation, AssetRefRd lookup(ASSETNUM == ASSETNUM_ref",
						"     && SITE_ID == SITE_ID_ref,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'both')~> lkpAssetOptn",
						"lkpAssetOptn, PersonRefRd lookup(WO_STATUS_CHANGEBY == PERSON_NBR",
						"     && OrgSiteRefRd@ORGANIZATION_ID == PersonRefRd@ORGANIZATION_ID",
						"     && OrgSiteRefRd@SITE_ID == PersonRefRd@SITE_ID,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'both')~> lkpPersonOptn",
						"lkpPersonOptn, JobplanRefRd lookup(JPNUM == JP_NUM",
						"     && OrgSiteRefRd@SITE_ID == JPRef_SITE_ID,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lkpJobplanOptn",
						"unionJobplan, PerGrpRefRd lookup(PERSONGROUP == PERSON_GRP_CD,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lkpPerGrpOptn",
						"lkpOrgsiteoptn, LocationRefRd lookup(LOCATION == DIM_LOCATION",
						"     && SITEID == LOC_SITE_NM,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lkpLocation",
						"OpsExistingRows select(mapColumn(",
						"          ExistWONUM = WONUM,",
						"          ExistOPERATION_ID = OPERATION_ID,",
						"          ExistSITE_ID = SITE_ID,",
						"          ExistSTATUS = STATUS,",
						"          ExistWO_STATUS_CHANGEDATE = WO_STATUS_CHANGEDATE,",
						"          ExistSNAPSHOT_DATE = SNAPSHOT_DATE",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selOpsExistingRows",
						"selectOps2, selOpsExistingRows lookup(WONUM == ExistWONUM",
						"     && SITE_ID == ExistSITE_ID,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lkpExistOperation",
						"lkpExistOperation, MaxKey join(1==1,",
						"     joinType:'cross',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinMaxKey",
						"selOperation keyGenerate(output(NewOPERATION_ID as long),",
						"     startAt: 1L,",
						"     stepValue: 1L,",
						"     partitionBy('hash', 1)) ~> skOperation",
						"skOperation derive(OPERATION_ID = MAXKEY + NewOPERATION_ID) ~> dcOperationInsert",
						"dcOperationInsert alterRow(insertIf(1==1)) ~> alterRowOpsInsert",
						"lkpPerGrpOptn select(mapColumn(",
						"          WONUM,",
						"          PARENT,",
						"          GOVTWONUM,",
						"          LOCATION,",
						"          STATUS,",
						"          ASSETNUM,",
						"          JPNUM,",
						"          WO_STATUS_CHANGEDATE,",
						"          WORKTYPE,",
						"          TASKID,",
						"          ISTASK,",
						"          DESCRIPTION,",
						"          PLUSCJPREVNUM,",
						"          WOPRIORITY,",
						"          WO_CHANGEDATE,",
						"          STATUSDATE,",
						"          WO_STATUS_CHANGEBY,",
						"          PMDUEDATE,",
						"          TARGSTARTDATE,",
						"          TARGCOMPDATE,",
						"          REPORTDATE,",
						"          ACTLABHRS,",
						"          ACTSTART,",
						"          ACTFINISH,",
						"          ACTINTLABHRS,",
						"          ESTDUR,",
						"          WOGROUP,",
						"          PERSONGROUP,",
						"          OWNERGROUP,",
						"          PLUSCFREQUENCY,",
						"          PLUSCFREQUNIT,",
						"          PMNEXTDUEDATE,",
						"          PMNUM,",
						"          ORGANIZATION_ID,",
						"          SITE_ID,",
						"          ORGANIZATION_NM,",
						"          SITE_NM,",
						"          LOCATION_ID,",
						"          DIM_LOCATION,",
						"          LOCATION_DESC,",
						"          LOC_SITE_NM,",
						"          ASSET_ID,",
						"          ASSETNUM_ref,",
						"          SITE_ID_ref,",
						"          PERSON_ID,",
						"          PERSON_NBR,",
						"          JP_ID,",
						"          JP_NUM,",
						"          PERSON_GROUP_ID",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectOps",
						"selectOps, srcWorkOrderReadRef lookup(WONUM == RefWONUM",
						"     && SITE_ID == RefSITE_ID",
						"     && STATUS == RefSTATUS",
						"     && WO_STATUS_CHANGEDATE == RefSTATUSDATE,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     partitionBy('hash', 4,",
						"          WONUM,",
						"          SITE_ID,",
						"          STATUS,",
						"          REPORTDATE",
						"     ),",
						"     broadcast: 'both')~> lookupOpsStatusInd",
						"dcOps select(mapColumn(",
						"          WONUM,",
						"          PARENT,",
						"          GOVTWONUM,",
						"          LOCATION,",
						"          STATUS,",
						"          ASSETNUM,",
						"          JPNUM,",
						"          WO_STATUS_CHANGEDATE,",
						"          WORKTYPE,",
						"          TASKID,",
						"          ISTASK,",
						"          DESCRIPTION,",
						"          PLUSCJPREVNUM,",
						"          WOPRIORITY,",
						"          WO_CHANGEDATE,",
						"          STATUSDATE,",
						"          WO_STATUS_CHANGEBY,",
						"          PMDUEDATE,",
						"          TARGSTARTDATE,",
						"          TARGCOMPDATE,",
						"          REPORTDATE,",
						"          ACTLABHRS,",
						"          ACTSTART,",
						"          ACTFINISH,",
						"          ACTINTLABHRS,",
						"          ESTDUR,",
						"          WOGROUP,",
						"          PERSONGROUP,",
						"          OWNERGROUP,",
						"          PLUSCFREQUENCY,",
						"          PLUSCFREQUNIT,",
						"          PMNEXTDUEDATE,",
						"          PMNUM,",
						"          ORGANIZATION_ID,",
						"          SITE_ID,",
						"          ORGANIZATION_NM,",
						"          SITE_NM,",
						"          LOCATION_ID,",
						"          DIM_LOCATION,",
						"          LOCATION_DESC,",
						"          LOC_SITE_NM,",
						"          ASSET_ID,",
						"          ASSETNUM_ref,",
						"          SITE_ID_ref,",
						"          PERSON_ID,",
						"          PERSON_NBR,",
						"          JP_ID,",
						"          JP_NUM,",
						"          PERSON_GROUP_ID,",
						"          CAL_PMDUEDT,",
						"          WORKTYPE_CM_PM,",
						"          {REPORTMONTH_YEAR },",
						"          REPORTDATE_MONTH,",
						"          REPORTDATE_CM_PM,",
						"          CURRENT_RECORD_IND,",
						"          EFFECTIVE_DT,",
						"          SNAPSHOT_DATE,",
						"          AVAILABLE_MANHOUR,",
						"          PARENT_ACTLABHRS,",
						"          STATUS_FLAG",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectOps2",
						"lkpExistOperation split(!isNull(ExistOPERATION_ID),",
						"     disjoint: false) ~> splitOpsForUpdate@(UpdateCurrRecInd, DoNotReprocessNewRecords)",
						"splitOpsForUpdate@UpdateCurrRecInd select(mapColumn(",
						"          WONUM,",
						"          SITE_ID,",
						"          CURRENT_RECORD_IND,",
						"          SNAPSHOT_DATE,",
						"          ExistWONUM,",
						"          ExistOPERATION_ID,",
						"          ExistSITE_ID,",
						"          ExistSNAPSHOT_DATE",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selOpsUpdate",
						"selOpsUpdate derive(NewCURRENT_RECORD_IND = toInteger(0)) ~> dcOpsUpdate",
						"dcOpsUpdate alterRow(updateIf(CURRENT_RECORD_IND==1)) ~> alterRowUpdate",
						"lkpJobplanOptn split(isNull(JP_ID),",
						"     disjoint: false) ~> splitJobPlan@(NullJobPlanSite, NotNullJobPlanSite)",
						"selectNullJPSite, selectJPNotNullSite union(byName: true)~> unionJobplan",
						"lkpJPNullSite select(mapColumn(",
						"          WONUM,",
						"          PARENT,",
						"          GOVTWONUM,",
						"          ORGID,",
						"          SITEID,",
						"          LOCATION,",
						"          STATUS,",
						"          ASSETNUM,",
						"          JPNUM,",
						"          WO_STATUS_CHANGEDATE,",
						"          WORKTYPE,",
						"          TASKID,",
						"          ISTASK,",
						"          DESCRIPTION,",
						"          PLUSCJPREVNUM,",
						"          WOPRIORITY,",
						"          WO_CHANGEDATE,",
						"          STATUSDATE,",
						"          WO_STATUS_CHANGEBY,",
						"          PMDUEDATE,",
						"          TARGSTARTDATE,",
						"          TARGCOMPDATE,",
						"          REPORTDATE,",
						"          ACTLABHRS,",
						"          ACTSTART,",
						"          ACTFINISH,",
						"          ACTINTLABHRS,",
						"          ESTDUR,",
						"          WOGROUP,",
						"          PERSONGROUP,",
						"          OWNERGROUP,",
						"          PLUSCFREQUENCY,",
						"          PLUSCFREQUNIT,",
						"          PMNEXTDUEDATE,",
						"          PMNUM,",
						"          ORGANIZATION_ID = splitJobPlan@NullJobPlanSite@ORGANIZATION_ID,",
						"          SITE_ID = splitJobPlan@NullJobPlanSite@SITE_ID,",
						"          ORGANIZATION_NM,",
						"          SITE_NM,",
						"          LOCATION_ID,",
						"          DIM_LOCATION,",
						"          LOCATION_DESC,",
						"          LOC_SITE_NM,",
						"          ASSET_ID,",
						"          ASSETNUM_ref,",
						"          SITE_ID_ref,",
						"          PERSON_ID,",
						"          PERSON_NBR,",
						"          JP_NUM = splitJobPlan@NullJobPlanSite@JP_NUM,",
						"          JPRef_SITE_ID = splitJobPlan@NullJobPlanSite@JPRef_SITE_ID,",
						"          JPRef_ORGANIZATION_ID = splitJobPlan@NullJobPlanSite@JPRef_ORGANIZATION_ID,",
						"          JP_ID = JobplanNullSiteRd@JP_ID",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectNullJPSite",
						"splitJobPlan@NotNullJobPlanSite select(mapColumn(",
						"          WONUM,",
						"          PARENT,",
						"          GOVTWONUM,",
						"          ORGID,",
						"          SITEID,",
						"          LOCATION,",
						"          STATUS,",
						"          ASSETNUM,",
						"          JPNUM,",
						"          WO_STATUS_CHANGEDATE,",
						"          WORKTYPE,",
						"          TASKID,",
						"          ISTASK,",
						"          DESCRIPTION,",
						"          PLUSCJPREVNUM,",
						"          WOPRIORITY,",
						"          WO_CHANGEDATE,",
						"          STATUSDATE,",
						"          WO_STATUS_CHANGEBY,",
						"          PMDUEDATE,",
						"          TARGSTARTDATE,",
						"          TARGCOMPDATE,",
						"          REPORTDATE,",
						"          ACTLABHRS,",
						"          ACTSTART,",
						"          ACTFINISH,",
						"          ACTINTLABHRS,",
						"          ESTDUR,",
						"          WOGROUP,",
						"          PERSONGROUP,",
						"          OWNERGROUP,",
						"          PLUSCFREQUENCY,",
						"          PLUSCFREQUNIT,",
						"          PMNEXTDUEDATE,",
						"          PMNUM,",
						"          ORGANIZATION_ID = splitJobPlan@NotNullJobPlanSite@ORGANIZATION_ID,",
						"          SITE_ID = splitJobPlan@NotNullJobPlanSite@SITE_ID,",
						"          ORGANIZATION_NM,",
						"          SITE_NM,",
						"          LOCATION_ID,",
						"          DIM_LOCATION,",
						"          LOCATION_DESC,",
						"          LOC_SITE_NM,",
						"          ASSET_ID,",
						"          ASSETNUM_ref,",
						"          SITE_ID_ref,",
						"          PERSON_ID,",
						"          PERSON_NBR,",
						"          JP_ID,",
						"          JP_NUM,",
						"          JPRef_SITE_ID,",
						"          JPRef_ORGANIZATION_ID",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectJPNotNullSite",
						"splitJobPlan@NullJobPlanSite, JobplanNullSiteRd lookup(JPNUM == JobplanNullSiteRd@JP_NUM",
						"     && splitJobPlan@NullJobPlanSite@ORGANIZATION_ID == JobplanNullSiteRd@JPRef_ORGANIZATION_ID,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lkpJPNullSite",
						"alterRowOpsInsert sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          OPERATION_ID as integer,",
						"          WONUM as string,",
						"          PARENT as string,",
						"          GOVTWONUM as string,",
						"          ORGANIZATION_ID as integer,",
						"          SITE_ID as integer,",
						"          LOCATION_ID as integer,",
						"          ASSET_ID as integer,",
						"          PERSON_ID as integer,",
						"          JP_ID as integer,",
						"          PERSON_GROUP_ID as integer,",
						"          STATUS as string,",
						"          WORKTYPE as string,",
						"          TASKID as integer,",
						"          ISTASK as integer,",
						"          DESCRIPTION as string,",
						"          PLUSCJREVNUM as integer,",
						"          WOPRIORITY as string,",
						"          WO_CHANGEDATE as timestamp,",
						"          WO_STATUS_CHANGEDATE as timestamp,",
						"          WO_STATUS_CHANGEBY as string,",
						"          STATUSDATE as timestamp,",
						"          PMDUEDATE as timestamp,",
						"          TARGSTARTDATE as timestamp,",
						"          TARGCOMPDATE as timestamp,",
						"          REPORTDATE as timestamp,",
						"          ACTLABHRS as decimal(18,9),",
						"          ACTSTART as timestamp,",
						"          ACTFINISH as timestamp,",
						"          ACTINTLABHRS as decimal(18,9),",
						"          ESTDUR as decimal(18,9),",
						"          WOGROUP as string,",
						"          PERSON_GROUP as string,",
						"          CAL_PMDUEDT as timestamp,",
						"          WORKTYPE_CM_PM as string,",
						"          REPORTMONTH_YEAR as string,",
						"          REPORTDATE_MONTH as string,",
						"          REPORTDATE_CM_PM as timestamp,",
						"          PLUSCFREQUENCY as integer,",
						"          PLUSCFREQUNIT as string,",
						"          PMNEXTDUEDATE as date,",
						"          PMNUM as string,",
						"          AVAILABLE_MANHOUR as integer,",
						"          PARENT_ACTLABHRS as decimal(18,9),",
						"          SNAPSHOT_DATE as timestamp,",
						"          CURRENT_RECORD_IND as integer,",
						"          EFFECTIVE_DT as timestamp,",
						"          STATUS_FLAG as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     staged: true,",
						"     allowCopyCommand: true,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     saveOrder: 2,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          OPERATION_ID,",
						"          WONUM,",
						"          PARENT,",
						"          GOVTWONUM,",
						"          ORGANIZATION_ID,",
						"          SITE_ID,",
						"          LOCATION_ID,",
						"          ASSET_ID,",
						"          PERSON_ID,",
						"          JP_ID,",
						"          PERSON_GROUP_ID,",
						"          STATUS,",
						"          WORKTYPE,",
						"          TASKID,",
						"          ISTASK,",
						"          DESCRIPTION,",
						"          PLUSCJREVNUM = PLUSCREVNUM,",
						"          WOPRIORITY,",
						"          WO_CHANGEDATE,",
						"          WO_STATUS_CHANGEDATE,",
						"          WO_STATUS_CHANGEBY,",
						"          STATUSDATE,",
						"          PMDUEDATE,",
						"          TARGSTARTDATE,",
						"          TARGCOMPDATE,",
						"          REPORTDATE,",
						"          ACTLABHRS,",
						"          ACTSTART,",
						"          ACTFINISH,",
						"          ACTINTLABHRS,",
						"          ESTDUR,",
						"          WOGROUP,",
						"          PERSON_GROUP,",
						"          CAL_PMDUEDT,",
						"          WORKTYPE_CM_PM,",
						"          REPORTMONTH_YEAR = {REPORTMONTH_YEAR },",
						"          REPORTDATE_MONTH,",
						"          REPORTDATE_CM_PM,",
						"          PLUSCFREQUENCY,",
						"          PLUSCFREQUNIT,",
						"          PMNEXTDUEDATE,",
						"          PMNUM,",
						"          AVAILABLE_MANHOUR,",
						"          PARENT_ACTLABHRS,",
						"          SNAPSHOT_DATE,",
						"          CURRENT_RECORD_IND,",
						"          EFFECTIVE_DT,",
						"          STATUS_FLAG",
						"     )) ~> sinkOpsInsert",
						"alterRowUpdate sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          OPERATION_ID as integer,",
						"          WONUM as string,",
						"          PARENT as string,",
						"          GOVTWONUM as string,",
						"          ORGANIZATION_ID as integer,",
						"          SITE_ID as integer,",
						"          LOCATION_ID as integer,",
						"          ASSET_ID as integer,",
						"          PERSON_ID as integer,",
						"          JP_ID as integer,",
						"          PERSON_GROUP_ID as integer,",
						"          STATUS as string,",
						"          WORKTYPE as string,",
						"          TASKID as integer,",
						"          ISTASK as integer,",
						"          DESCRIPTION as string,",
						"          PLUSCJREVNUM as integer,",
						"          WOPRIORITY as string,",
						"          WO_CHANGEDATE as timestamp,",
						"          WO_STATUS_CHANGEDATE as timestamp,",
						"          WO_STATUS_CHANGEBY as string,",
						"          STATUSDATE as timestamp,",
						"          PMDUEDATE as timestamp,",
						"          TARGSTARTDATE as timestamp,",
						"          TARGCOMPDATE as timestamp,",
						"          REPORTDATE as timestamp,",
						"          ACTLABHRS as decimal(18,9),",
						"          ACTSTART as timestamp,",
						"          ACTFINISH as timestamp,",
						"          ACTINTLABHRS as decimal(18,9),",
						"          ESTDUR as decimal(18,9),",
						"          WOGROUP as string,",
						"          PERSON_GROUP as string,",
						"          CAL_PMDUEDT as timestamp,",
						"          WORKTYPE_CM_PM as string,",
						"          REPORTMONTH_YEAR as string,",
						"          REPORTDATE_MONTH as string,",
						"          REPORTDATE_CM_PM as timestamp,",
						"          PLUSCFREQUENCY as integer,",
						"          PLUSCFREQUNIT as string,",
						"          PMNEXTDUEDATE as date,",
						"          PMNUM as string,",
						"          AVAILABLE_MANHOUR as integer,",
						"          PARENT_ACTLABHRS as decimal(18,9),",
						"          SNAPSHOT_DATE as timestamp,",
						"          CURRENT_RECORD_IND as integer,",
						"          EFFECTIVE_DT as timestamp,",
						"          STATUS_FLAG as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['OPERATION_ID'],",
						"     format: 'table',",
						"     staged: true,",
						"     allowCopyCommand: true,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     saveOrder: 1,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          OPERATION_ID = ExistOPERATION_ID,",
						"          CURRENT_RECORD_IND = NewCURRENT_RECORD_IND",
						"     )) ~> sinkOperationUpdate"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/dp_OperationLdFact_df1')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "AzSnpMXMSTGAsset31",
								"type": "DatasetReference"
							},
							"name": "srcOperationRead"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd61",
								"type": "DatasetReference"
							},
							"name": "OrgSiteRefRd"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd61",
								"type": "DatasetReference"
							},
							"name": "AssetRefRd"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd61",
								"type": "DatasetReference"
							},
							"name": "PersonRefRd"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd61",
								"type": "DatasetReference"
							},
							"name": "JobplanRefRd"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd61",
								"type": "DatasetReference"
							},
							"name": "PerGrpRefRd"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd61",
								"type": "DatasetReference"
							},
							"name": "LocationRefRd"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd61",
								"type": "DatasetReference"
							},
							"name": "MaxKey"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd61",
								"type": "DatasetReference"
							},
							"name": "OpsExistingRows"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd61",
								"type": "DatasetReference"
							},
							"name": "srcWorkOrderReadRef"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd61",
								"type": "DatasetReference"
							},
							"name": "JobplanNullSiteRd"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "SinkOperationLd21",
								"type": "DatasetReference"
							},
							"name": "sinkOpsInsert"
						},
						{
							"dataset": {
								"referenceName": "SinkOperationLd21",
								"type": "DatasetReference"
							},
							"name": "sinkOperationUpdate"
						}
					],
					"transformations": [
						{
							"name": "srtOperation"
						},
						{
							"name": "dcOps"
						},
						{
							"name": "selOperation"
						},
						{
							"name": "lkpOrgsiteoptn"
						},
						{
							"name": "lkpAssetOptn"
						},
						{
							"name": "lkpPersonOptn"
						},
						{
							"name": "lkpJobplanOptn"
						},
						{
							"name": "lkpPerGrpOptn"
						},
						{
							"name": "lkpLocation"
						},
						{
							"name": "selOpsExistingRows"
						},
						{
							"name": "lkpExistOperation"
						},
						{
							"name": "joinMaxKey"
						},
						{
							"name": "skOperation"
						},
						{
							"name": "dcOperationInsert"
						},
						{
							"name": "alterRowOpsInsert"
						},
						{
							"name": "selectOps"
						},
						{
							"name": "lookupOpsStatusInd"
						},
						{
							"name": "selectOps2"
						},
						{
							"name": "splitOpsForUpdate"
						},
						{
							"name": "selOpsUpdate"
						},
						{
							"name": "dcOpsUpdate"
						},
						{
							"name": "alterRowUpdate"
						},
						{
							"name": "splitJobPlan"
						},
						{
							"name": "unionJobplan"
						},
						{
							"name": "selectNullJPSite"
						},
						{
							"name": "selectJPNotNullSite"
						},
						{
							"name": "lkpJPNullSite"
						}
					],
					"scriptLines": [
						"source(output(",
						"          WONUM as string,",
						"          PARENT as string,",
						"          GOVTWONUM as string,",
						"          ORGID as string,",
						"          SITEID as string,",
						"          LOCATION as string,",
						"          STATUS as string,",
						"          ASSETNUM as string,",
						"          JPNUM as string,",
						"          WO_STATUS_CHANGEDATE as timestamp,",
						"          WORKTYPE as string,",
						"          TASKID as integer,",
						"          ISTASK as integer,",
						"          DESCRIPTION as string,",
						"          PLUSCJPREVNUM as integer,",
						"          WOPRIORITY as integer,",
						"          WO_CHANGEDATE as timestamp,",
						"          STATUSDATE as timestamp,",
						"          WO_STATUS_CHANGEBY as string,",
						"          PMDUEDATE as date,",
						"          TARGSTARTDATE as timestamp,",
						"          TARGCOMPDATE as timestamp,",
						"          REPORTDATE as timestamp,",
						"          ACTLABHRS as decimal(18,9),",
						"          ACTSTART as timestamp,",
						"          ACTFINISH as timestamp,",
						"          ACTINTLABHRS as decimal(18,9),",
						"          ESTDUR as decimal(18,9),",
						"          WOGROUP as string,",
						"          PERSONGROUP as string,",
						"          OWNERGROUP as string,",
						"          PLUSCFREQUENCY as integer,",
						"          PLUSCFREQUNIT as string,",
						"          PMNEXTDUEDATE as date,",
						"          PMNUM as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     inferDriftedColumnTypes: true,",
						"     isolationLevel: 'READ_COMMITTED',",
						"     query: 'SELECT \\nWO.WONUM AS WONUM,WO.PARENT AS PARENT,GOVTWONUM,WO.ORGID,WO.SITEID,LOCATION,WS.STATUS AS STATUS,ASSETNUM,JPNUM, WS.CHANGEDATE AS WO_STATUS_CHANGEDATE,\\nWORKTYPE,TASKID,ISTASK, DESCRIPTION,PLUSCJPREVNUM,WOPRIORITY,WO.CHANGEDATE AS WO_CHANGEDATE,STATUSDATE,WS.CHANGEBY AS WO_STATUS_CHANGEBY, PMDUEDATE,\\nTARGSTARTDATE,TARGCOMPDATE,REPORTDATE,ACTLABHRS,ACTSTART, ACTFINISH,ACTINTLABHRS,ESTDUR,WOGROUP,PERSONGROUP,OWNERGROUP,PLUSCFREQUENCY,PLUSCFREQUNIT,\\nPMNEXTDUEDATE,PMNUM\\nFROM MXMSTG.STG_WORKORDER WO, MXMSTG.STG_WOSTATUS WS\\n WHERE\\n WS.WONUM=WO.WONUM\\n AND WS.ORGID=WO.ORGID\\n AND WS.SITEID=WO.SITEID',",
						"     format: 'query',",
						"     staged: true) ~> srcOperationRead",
						"source(output(",
						"          ORGANIZATION_ID as integer,",
						"          SITE_ID as integer,",
						"          ORGANIZATION_NM as string,",
						"          SITE_NM as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT O.ORGANIZATION_ID,S.SITE_ID,O.ORGANIZATION_NM,S.SITE_NM\\nFROM\\nMXMDW.ORGANIZATION O,\\nMXMDW.SITE S\\nWHERE\\nS.ORGANIZATION_ID=O.ORGANIZATION_ID',",
						"     format: 'query',",
						"     staged: true) ~> OrgSiteRefRd",
						"source(output(",
						"          ASSET_ID as integer,",
						"          ASSETNUM_ref as string,",
						"          SITE_ID_ref as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT ASSET_ID,ASSETNUM AS ASSETNUM_ref,SITE_ID AS SITE_ID_ref FROM MXMDW.ASSET',",
						"     format: 'query',",
						"     staged: true) ~> AssetRefRd",
						"source(output(",
						"          PERSON_ID as integer,",
						"          PERSON_NBR as string,",
						"          SITE_ID as integer,",
						"          ORGANIZATION_ID as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT PERSON_ID,PERSON_NBR,P.SITE_ID AS SITE_ID,S.ORGANIZATION_ID AS ORGANIZATION_ID FROM \\nMXMDW.PERSON P,\\nMXMDW.ORGANIZATION O,\\nMXMDW.SITE S\\nWHERE\\nO.ORGANIZATION_ID =S.ORGANIZATION_ID\\nAND S.SITE_ID=P.SITE_ID',",
						"     format: 'query',",
						"     staged: true) ~> PersonRefRd",
						"source(output(",
						"          JP_ID as integer,",
						"          JP_NUM as string,",
						"          JPRef_SITE_ID as integer,",
						"          JPRef_ORGANIZATION_ID as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT JP_ID,JP_NUM,SITE_ID AS JPRef_SITE_ID,ORGANIZATION_ID AS JPRef_ORGANIZATION_ID FROM MXMDW.JOBPLAN WHERE STATUS=\\'ACTIVE\\' AND SITE_ID>0',",
						"     format: 'query',",
						"     staged: true) ~> JobplanRefRd",
						"source(output(",
						"          PERSON_GROUP_ID as integer,",
						"          PERSON_GRP_CD as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT PERSON_GROUP_ID,PERSON_GRP_CD FROM MXMDW.PERSON_GROUP',",
						"     format: 'query',",
						"     staged: true) ~> PerGrpRefRd",
						"source(output(",
						"          LOCATION_ID as integer,",
						"          DIM_LOCATION as string,",
						"          LOCATION_DESC as string,",
						"          LOC_SITE_NM as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT L.LOCATION_ID AS LOCATION_ID,L.LOCATION AS DIM_LOCATION,L.DESCRIPTION AS LOCATION_DESC, S.SITE_NM AS LOC_SITE_NM\\nFROM MXMDW.LOCATIONS L\\nINNER JOIN MXMDW.SITE S\\nON S.SITE_ID = L.SITE_ID',",
						"     format: 'query',",
						"     staged: true) ~> LocationRefRd",
						"source(output(",
						"          MAXKEY as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT MAXKEY=ISNULL(MAX(OPERATION_ID),0) FROM  MXMDW.OPERATION',",
						"     format: 'query',",
						"     staged: true) ~> MaxKey",
						"source(output(",
						"          OPERATION_ID as integer,",
						"          WONUM as string,",
						"          SITE_ID as integer,",
						"          STATUS as string,",
						"          WO_STATUS_CHANGEDATE as timestamp,",
						"          SNAPSHOT_DATE as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT OPERATION_ID, WONUM,SITE_ID,STATUS,WO_STATUS_CHANGEDATE,SNAPSHOT_DATE FROM MXMDW.OPERATION WHERE CURRENT_RECORD_IND=1',",
						"     format: 'query',",
						"     staged: true,",
						"     partitionBy('hash', 1)) ~> OpsExistingRows",
						"source(output(",
						"          RefWONUM as string,",
						"          RefSITE_ID as integer,",
						"          RefSTATUS as string,",
						"          RefSTATUSDATE as timestamp,",
						"          FLAG as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT WONUM AS RefWONUM,S.SITE_ID AS RefSITE_ID,STATUS AS RefSTATUS,STATUSDATE AS RefSTATUSDATE,\\'1\\' AS FLAG FROM MXMSTG.STG_WORKORDER WO,MXMDW.SITE S\\nWHERE\\nWO.SITEID=S.SITE_NM',",
						"     format: 'query',",
						"     staged: true) ~> srcWorkOrderReadRef",
						"source(output(",
						"          JP_ID as integer,",
						"          JP_NUM as string,",
						"          JPRef_SITE_ID as integer,",
						"          JPRef_ORGANIZATION_ID as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT JP_ID,JP_NUM,SITE_ID AS JPRef_SITE_ID,ORGANIZATION_ID AS JPRef_ORGANIZATION_ID FROM MXMDW.JOBPLAN WHERE STATUS=\\'ACTIVE\\' AND SITE_ID<0',",
						"     format: 'query',",
						"     staged: true) ~> JobplanNullSiteRd",
						"srcOperationRead sort(asc(WONUM, true),",
						"     asc(PARENT, true),",
						"     asc(ORGID, true),",
						"     asc(SITEID, true),",
						"     asc(WO_STATUS_CHANGEDATE, true),",
						"     caseInsensitive: true) ~> srtOperation",
						"lookupOpsStatusInd derive(CAL_PMDUEDT = iifNull(PMDUEDATE, TARGSTARTDATE,REPORTDATE),",
						"          WORKTYPE_CM_PM = case(\r",
						"     (WORKTYPE == 'CM' || WORKTYPE == 'DMO' || WORKTYPE == 'OWO' || WORKTYPE == 'SERV'), 'CM',\r",
						"     (WORKTYPE == 'PM' || WORKTYPE == 'INSP' || WORKTYPE == 'SWM' || WORKTYPE == 'PMO'), 'PM',\r",
						"        (WORKTYPE == 'PJ' || WORKTYPE == 'PWO' ), 'PJ',\r",
						"        'OTHERS'  \r",
						"     ),",
						"          {REPORTMONTH_YEAR } = year(REPORTDATE),",
						"          REPORTDATE_MONTH = month(REPORTDATE),",
						"          REPORTDATE_CM_PM = case(     \r",
						"     (WORKTYPE == 'PM' || WORKTYPE == 'INSP' || WORKTYPE == 'SWM' || WORKTYPE == 'PMO'), iifNull(PMDUEDATE, TARGSTARTDATE,REPORTDATE),       \r",
						"        REPORTDATE  \r",
						"     ),",
						"          CURRENT_RECORD_IND = iifNull(toInteger(FLAG), 0, 1),",
						"          EFFECTIVE_DT = currentTimestamp(),",
						"          SNAPSHOT_DATE = toTimestamp(toString(WO_STATUS_CHANGEDATE, 'yyyy-MM-dd 00:00:00'),'yyyy-MM-dd HH:mm:ss'),",
						"          ASSET_ID = iifNull(ASSET_ID, toInteger(-1), ASSET_ID),",
						"          PERSON_ID = iifNull(PERSON_ID, toInteger(-1), PERSON_ID),",
						"          JP_ID = iifNull(JP_ID, toInteger(-1), JP_ID),",
						"          PERSON_GROUP_ID = iifNull(PERSON_GROUP_ID, toInteger(-1), PERSON_GROUP_ID),",
						"          LOCATION_ID = iifNull(LOCATION_ID, toInteger(-1), LOCATION_ID),",
						"          AVAILABLE_MANHOUR = toInteger(506),",
						"          PARENT_ACTLABHRS = toDecimal(0.0),",
						"          STATUS_FLAG = case(     \r",
						"     (STATUS == 'READY' || STATUS == 'CLOSE' || STATUS == 'CAN' || STATUS == 'COMP'), 2,1        \r",
						"     )) ~> dcOps",
						"joinMaxKey select(mapColumn(",
						"          WONUM,",
						"          PARENT,",
						"          GOVTWONUM,",
						"          LOCATION_ID,",
						"          STATUS,",
						"          WO_STATUS_CHANGEDATE,",
						"          WORKTYPE,",
						"          TASKID,",
						"          ISTASK,",
						"          DESCRIPTION,",
						"          PLUSCREVNUM = PLUSCJPREVNUM,",
						"          WOPRIORITY,",
						"          STATUSDATE,",
						"          WO_STATUS_CHANGEBY,",
						"          PMDUEDATE,",
						"          TARGSTARTDATE,",
						"          TARGCOMPDATE,",
						"          REPORTDATE,",
						"          WO_CHANGEDATE,",
						"          ACTLABHRS,",
						"          ACTSTART,",
						"          ACTFINISH,",
						"          ACTINTLABHRS,",
						"          WOGROUP,",
						"          CAL_PMDUEDT,",
						"          WORKTYPE_CM_PM,",
						"          {REPORTMONTH_YEAR },",
						"          REPORTDATE_MONTH,",
						"          REPORTDATE_CM_PM,",
						"          CURRENT_RECORD_IND,",
						"          EFFECTIVE_DT,",
						"          SNAPSHOT_DATE,",
						"          ORGANIZATION_ID,",
						"          SITE_ID,",
						"          LOCATION_ID,",
						"          ASSET_ID,",
						"          PERSON_ID,",
						"          JP_ID,",
						"          PERSON_GROUP_ID,",
						"          PERSON_GROUP = PERSONGROUP,",
						"          ESTDUR,",
						"          PLUSCFREQUENCY,",
						"          PLUSCFREQUNIT,",
						"          PMNEXTDUEDATE,",
						"          PMNUM,",
						"          AVAILABLE_MANHOUR,",
						"          CURRENT_RECORD_IND,",
						"          PARENT_ACTLABHRS,",
						"          MAXKEY,",
						"          STATUS_FLAG",
						"     ),",
						"     partitionBy('hash', 1),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selOperation",
						"srtOperation, OrgSiteRefRd lookup(ORGID == ORGANIZATION_NM",
						"     && SITEID == SITE_NM,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lkpOrgsiteoptn",
						"lkpLocation, AssetRefRd lookup(ASSETNUM == ASSETNUM_ref",
						"     && SITE_ID == SITE_ID_ref,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'both')~> lkpAssetOptn",
						"lkpAssetOptn, PersonRefRd lookup(WO_STATUS_CHANGEBY == PERSON_NBR",
						"     && OrgSiteRefRd@ORGANIZATION_ID == PersonRefRd@ORGANIZATION_ID",
						"     && OrgSiteRefRd@SITE_ID == PersonRefRd@SITE_ID,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'both')~> lkpPersonOptn",
						"lkpPersonOptn, JobplanRefRd lookup(JPNUM == JP_NUM",
						"     && OrgSiteRefRd@SITE_ID == JPRef_SITE_ID,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lkpJobplanOptn",
						"unionJobplan, PerGrpRefRd lookup(PERSONGROUP == PERSON_GRP_CD,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lkpPerGrpOptn",
						"lkpOrgsiteoptn, LocationRefRd lookup(LOCATION == DIM_LOCATION",
						"     && SITEID == LOC_SITE_NM,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lkpLocation",
						"OpsExistingRows select(mapColumn(",
						"          ExistWONUM = WONUM,",
						"          ExistOPERATION_ID = OPERATION_ID,",
						"          ExistSITE_ID = SITE_ID,",
						"          ExistSTATUS = STATUS,",
						"          ExistWO_STATUS_CHANGEDATE = WO_STATUS_CHANGEDATE,",
						"          ExistSNAPSHOT_DATE = SNAPSHOT_DATE",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selOpsExistingRows",
						"selectOps2, selOpsExistingRows lookup(WONUM == ExistWONUM",
						"     && SITE_ID == ExistSITE_ID,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lkpExistOperation",
						"lkpExistOperation, MaxKey join(1==1,",
						"     joinType:'cross',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinMaxKey",
						"selOperation keyGenerate(output(NewOPERATION_ID as long),",
						"     startAt: 1L,",
						"     stepValue: 1L,",
						"     partitionBy('hash', 1)) ~> skOperation",
						"skOperation derive(OPERATION_ID = MAXKEY + NewOPERATION_ID) ~> dcOperationInsert",
						"dcOperationInsert alterRow(insertIf(1==1)) ~> alterRowOpsInsert",
						"lkpPerGrpOptn select(mapColumn(",
						"          WONUM,",
						"          PARENT,",
						"          GOVTWONUM,",
						"          LOCATION,",
						"          STATUS,",
						"          ASSETNUM,",
						"          JPNUM,",
						"          WO_STATUS_CHANGEDATE,",
						"          WORKTYPE,",
						"          TASKID,",
						"          ISTASK,",
						"          DESCRIPTION,",
						"          PLUSCJPREVNUM,",
						"          WOPRIORITY,",
						"          WO_CHANGEDATE,",
						"          STATUSDATE,",
						"          WO_STATUS_CHANGEBY,",
						"          PMDUEDATE,",
						"          TARGSTARTDATE,",
						"          TARGCOMPDATE,",
						"          REPORTDATE,",
						"          ACTLABHRS,",
						"          ACTSTART,",
						"          ACTFINISH,",
						"          ACTINTLABHRS,",
						"          ESTDUR,",
						"          WOGROUP,",
						"          PERSONGROUP,",
						"          OWNERGROUP,",
						"          PLUSCFREQUENCY,",
						"          PLUSCFREQUNIT,",
						"          PMNEXTDUEDATE,",
						"          PMNUM,",
						"          ORGANIZATION_ID,",
						"          SITE_ID,",
						"          ORGANIZATION_NM,",
						"          SITE_NM,",
						"          LOCATION_ID,",
						"          DIM_LOCATION,",
						"          LOCATION_DESC,",
						"          LOC_SITE_NM,",
						"          ASSET_ID,",
						"          ASSETNUM_ref,",
						"          SITE_ID_ref,",
						"          PERSON_ID,",
						"          PERSON_NBR,",
						"          JP_ID,",
						"          JP_NUM,",
						"          PERSON_GROUP_ID",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectOps",
						"selectOps, srcWorkOrderReadRef lookup(WONUM == RefWONUM",
						"     && SITE_ID == RefSITE_ID",
						"     && STATUS == RefSTATUS",
						"     && WO_STATUS_CHANGEDATE == RefSTATUSDATE,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     partitionBy('hash', 4,",
						"          WONUM,",
						"          SITE_ID,",
						"          STATUS,",
						"          REPORTDATE",
						"     ),",
						"     broadcast: 'both')~> lookupOpsStatusInd",
						"dcOps select(mapColumn(",
						"          WONUM,",
						"          PARENT,",
						"          GOVTWONUM,",
						"          LOCATION,",
						"          STATUS,",
						"          ASSETNUM,",
						"          JPNUM,",
						"          WO_STATUS_CHANGEDATE,",
						"          WORKTYPE,",
						"          TASKID,",
						"          ISTASK,",
						"          DESCRIPTION,",
						"          PLUSCJPREVNUM,",
						"          WOPRIORITY,",
						"          WO_CHANGEDATE,",
						"          STATUSDATE,",
						"          WO_STATUS_CHANGEBY,",
						"          PMDUEDATE,",
						"          TARGSTARTDATE,",
						"          TARGCOMPDATE,",
						"          REPORTDATE,",
						"          ACTLABHRS,",
						"          ACTSTART,",
						"          ACTFINISH,",
						"          ACTINTLABHRS,",
						"          ESTDUR,",
						"          WOGROUP,",
						"          PERSONGROUP,",
						"          OWNERGROUP,",
						"          PLUSCFREQUENCY,",
						"          PLUSCFREQUNIT,",
						"          PMNEXTDUEDATE,",
						"          PMNUM,",
						"          ORGANIZATION_ID,",
						"          SITE_ID,",
						"          ORGANIZATION_NM,",
						"          SITE_NM,",
						"          LOCATION_ID,",
						"          DIM_LOCATION,",
						"          LOCATION_DESC,",
						"          LOC_SITE_NM,",
						"          ASSET_ID,",
						"          ASSETNUM_ref,",
						"          SITE_ID_ref,",
						"          PERSON_ID,",
						"          PERSON_NBR,",
						"          JP_ID,",
						"          JP_NUM,",
						"          PERSON_GROUP_ID,",
						"          CAL_PMDUEDT,",
						"          WORKTYPE_CM_PM,",
						"          {REPORTMONTH_YEAR },",
						"          REPORTDATE_MONTH,",
						"          REPORTDATE_CM_PM,",
						"          CURRENT_RECORD_IND,",
						"          EFFECTIVE_DT,",
						"          SNAPSHOT_DATE,",
						"          AVAILABLE_MANHOUR,",
						"          PARENT_ACTLABHRS,",
						"          STATUS_FLAG",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectOps2",
						"lkpExistOperation split(!isNull(ExistOPERATION_ID),",
						"     disjoint: false) ~> splitOpsForUpdate@(UpdateCurrRecInd, DoNotReprocessNewRecords)",
						"splitOpsForUpdate@UpdateCurrRecInd select(mapColumn(",
						"          WONUM,",
						"          SITE_ID,",
						"          CURRENT_RECORD_IND,",
						"          SNAPSHOT_DATE,",
						"          ExistWONUM,",
						"          ExistOPERATION_ID,",
						"          ExistSITE_ID,",
						"          ExistSNAPSHOT_DATE",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selOpsUpdate",
						"selOpsUpdate derive(NewCURRENT_RECORD_IND = toInteger(0)) ~> dcOpsUpdate",
						"dcOpsUpdate alterRow(updateIf(CURRENT_RECORD_IND==1)) ~> alterRowUpdate",
						"lkpJobplanOptn split(isNull(JP_ID),",
						"     disjoint: false) ~> splitJobPlan@(NullJobPlanSite, NotNullJobPlanSite)",
						"selectNullJPSite, selectJPNotNullSite union(byName: true)~> unionJobplan",
						"lkpJPNullSite select(mapColumn(",
						"          WONUM,",
						"          PARENT,",
						"          GOVTWONUM,",
						"          ORGID,",
						"          SITEID,",
						"          LOCATION,",
						"          STATUS,",
						"          ASSETNUM,",
						"          JPNUM,",
						"          WO_STATUS_CHANGEDATE,",
						"          WORKTYPE,",
						"          TASKID,",
						"          ISTASK,",
						"          DESCRIPTION,",
						"          PLUSCJPREVNUM,",
						"          WOPRIORITY,",
						"          WO_CHANGEDATE,",
						"          STATUSDATE,",
						"          WO_STATUS_CHANGEBY,",
						"          PMDUEDATE,",
						"          TARGSTARTDATE,",
						"          TARGCOMPDATE,",
						"          REPORTDATE,",
						"          ACTLABHRS,",
						"          ACTSTART,",
						"          ACTFINISH,",
						"          ACTINTLABHRS,",
						"          ESTDUR,",
						"          WOGROUP,",
						"          PERSONGROUP,",
						"          OWNERGROUP,",
						"          PLUSCFREQUENCY,",
						"          PLUSCFREQUNIT,",
						"          PMNEXTDUEDATE,",
						"          PMNUM,",
						"          ORGANIZATION_ID = splitJobPlan@NullJobPlanSite@ORGANIZATION_ID,",
						"          SITE_ID = splitJobPlan@NullJobPlanSite@SITE_ID,",
						"          ORGANIZATION_NM,",
						"          SITE_NM,",
						"          LOCATION_ID,",
						"          DIM_LOCATION,",
						"          LOCATION_DESC,",
						"          LOC_SITE_NM,",
						"          ASSET_ID,",
						"          ASSETNUM_ref,",
						"          SITE_ID_ref,",
						"          PERSON_ID,",
						"          PERSON_NBR,",
						"          JP_NUM = splitJobPlan@NullJobPlanSite@JP_NUM,",
						"          JPRef_SITE_ID = splitJobPlan@NullJobPlanSite@JPRef_SITE_ID,",
						"          JPRef_ORGANIZATION_ID = splitJobPlan@NullJobPlanSite@JPRef_ORGANIZATION_ID,",
						"          JP_ID = JobplanNullSiteRd@JP_ID",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectNullJPSite",
						"splitJobPlan@NotNullJobPlanSite select(mapColumn(",
						"          WONUM,",
						"          PARENT,",
						"          GOVTWONUM,",
						"          ORGID,",
						"          SITEID,",
						"          LOCATION,",
						"          STATUS,",
						"          ASSETNUM,",
						"          JPNUM,",
						"          WO_STATUS_CHANGEDATE,",
						"          WORKTYPE,",
						"          TASKID,",
						"          ISTASK,",
						"          DESCRIPTION,",
						"          PLUSCJPREVNUM,",
						"          WOPRIORITY,",
						"          WO_CHANGEDATE,",
						"          STATUSDATE,",
						"          WO_STATUS_CHANGEBY,",
						"          PMDUEDATE,",
						"          TARGSTARTDATE,",
						"          TARGCOMPDATE,",
						"          REPORTDATE,",
						"          ACTLABHRS,",
						"          ACTSTART,",
						"          ACTFINISH,",
						"          ACTINTLABHRS,",
						"          ESTDUR,",
						"          WOGROUP,",
						"          PERSONGROUP,",
						"          OWNERGROUP,",
						"          PLUSCFREQUENCY,",
						"          PLUSCFREQUNIT,",
						"          PMNEXTDUEDATE,",
						"          PMNUM,",
						"          ORGANIZATION_ID = splitJobPlan@NotNullJobPlanSite@ORGANIZATION_ID,",
						"          SITE_ID = splitJobPlan@NotNullJobPlanSite@SITE_ID,",
						"          ORGANIZATION_NM,",
						"          SITE_NM,",
						"          LOCATION_ID,",
						"          DIM_LOCATION,",
						"          LOCATION_DESC,",
						"          LOC_SITE_NM,",
						"          ASSET_ID,",
						"          ASSETNUM_ref,",
						"          SITE_ID_ref,",
						"          PERSON_ID,",
						"          PERSON_NBR,",
						"          JP_ID,",
						"          JP_NUM,",
						"          JPRef_SITE_ID,",
						"          JPRef_ORGANIZATION_ID",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectJPNotNullSite",
						"splitJobPlan@NullJobPlanSite, JobplanNullSiteRd lookup(JPNUM == JobplanNullSiteRd@JP_NUM",
						"     && splitJobPlan@NullJobPlanSite@ORGANIZATION_ID == JobplanNullSiteRd@JPRef_ORGANIZATION_ID,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lkpJPNullSite",
						"alterRowOpsInsert sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          OPERATION_ID as integer,",
						"          WONUM as string,",
						"          PARENT as string,",
						"          GOVTWONUM as string,",
						"          ORGANIZATION_ID as integer,",
						"          SITE_ID as integer,",
						"          LOCATION_ID as integer,",
						"          ASSET_ID as integer,",
						"          PERSON_ID as integer,",
						"          JP_ID as integer,",
						"          PERSON_GROUP_ID as integer,",
						"          STATUS as string,",
						"          WORKTYPE as string,",
						"          TASKID as integer,",
						"          ISTASK as integer,",
						"          DESCRIPTION as string,",
						"          PLUSCJREVNUM as integer,",
						"          WOPRIORITY as string,",
						"          WO_CHANGEDATE as timestamp,",
						"          WO_STATUS_CHANGEDATE as timestamp,",
						"          WO_STATUS_CHANGEBY as string,",
						"          STATUSDATE as timestamp,",
						"          PMDUEDATE as timestamp,",
						"          TARGSTARTDATE as timestamp,",
						"          TARGCOMPDATE as timestamp,",
						"          REPORTDATE as timestamp,",
						"          ACTLABHRS as decimal(18,9),",
						"          ACTSTART as timestamp,",
						"          ACTFINISH as timestamp,",
						"          ACTINTLABHRS as decimal(18,9),",
						"          ESTDUR as decimal(18,9),",
						"          WOGROUP as string,",
						"          PERSON_GROUP as string,",
						"          CAL_PMDUEDT as timestamp,",
						"          WORKTYPE_CM_PM as string,",
						"          REPORTMONTH_YEAR as string,",
						"          REPORTDATE_MONTH as string,",
						"          REPORTDATE_CM_PM as timestamp,",
						"          PLUSCFREQUENCY as integer,",
						"          PLUSCFREQUNIT as string,",
						"          PMNEXTDUEDATE as date,",
						"          PMNUM as string,",
						"          AVAILABLE_MANHOUR as integer,",
						"          PARENT_ACTLABHRS as decimal(18,9),",
						"          SNAPSHOT_DATE as timestamp,",
						"          CURRENT_RECORD_IND as integer,",
						"          EFFECTIVE_DT as timestamp,",
						"          STATUS_FLAG as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     staged: true,",
						"     allowCopyCommand: true,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     saveOrder: 2,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          OPERATION_ID,",
						"          WONUM,",
						"          PARENT,",
						"          GOVTWONUM,",
						"          ORGANIZATION_ID,",
						"          SITE_ID,",
						"          LOCATION_ID,",
						"          ASSET_ID,",
						"          PERSON_ID,",
						"          JP_ID,",
						"          PERSON_GROUP_ID,",
						"          STATUS,",
						"          WORKTYPE,",
						"          TASKID,",
						"          ISTASK,",
						"          DESCRIPTION,",
						"          PLUSCJREVNUM = PLUSCREVNUM,",
						"          WOPRIORITY,",
						"          WO_CHANGEDATE,",
						"          WO_STATUS_CHANGEDATE,",
						"          WO_STATUS_CHANGEBY,",
						"          STATUSDATE,",
						"          PMDUEDATE,",
						"          TARGSTARTDATE,",
						"          TARGCOMPDATE,",
						"          REPORTDATE,",
						"          ACTLABHRS,",
						"          ACTSTART,",
						"          ACTFINISH,",
						"          ACTINTLABHRS,",
						"          ESTDUR,",
						"          WOGROUP,",
						"          PERSON_GROUP,",
						"          CAL_PMDUEDT,",
						"          WORKTYPE_CM_PM,",
						"          REPORTMONTH_YEAR = {REPORTMONTH_YEAR },",
						"          REPORTDATE_MONTH,",
						"          REPORTDATE_CM_PM,",
						"          PLUSCFREQUENCY,",
						"          PLUSCFREQUNIT,",
						"          PMNEXTDUEDATE,",
						"          PMNUM,",
						"          AVAILABLE_MANHOUR,",
						"          PARENT_ACTLABHRS,",
						"          SNAPSHOT_DATE,",
						"          CURRENT_RECORD_IND,",
						"          EFFECTIVE_DT,",
						"          STATUS_FLAG",
						"     )) ~> sinkOpsInsert",
						"alterRowUpdate sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          OPERATION_ID as integer,",
						"          WONUM as string,",
						"          PARENT as string,",
						"          GOVTWONUM as string,",
						"          ORGANIZATION_ID as integer,",
						"          SITE_ID as integer,",
						"          LOCATION_ID as integer,",
						"          ASSET_ID as integer,",
						"          PERSON_ID as integer,",
						"          JP_ID as integer,",
						"          PERSON_GROUP_ID as integer,",
						"          STATUS as string,",
						"          WORKTYPE as string,",
						"          TASKID as integer,",
						"          ISTASK as integer,",
						"          DESCRIPTION as string,",
						"          PLUSCJREVNUM as integer,",
						"          WOPRIORITY as string,",
						"          WO_CHANGEDATE as timestamp,",
						"          WO_STATUS_CHANGEDATE as timestamp,",
						"          WO_STATUS_CHANGEBY as string,",
						"          STATUSDATE as timestamp,",
						"          PMDUEDATE as timestamp,",
						"          TARGSTARTDATE as timestamp,",
						"          TARGCOMPDATE as timestamp,",
						"          REPORTDATE as timestamp,",
						"          ACTLABHRS as decimal(18,9),",
						"          ACTSTART as timestamp,",
						"          ACTFINISH as timestamp,",
						"          ACTINTLABHRS as decimal(18,9),",
						"          ESTDUR as decimal(18,9),",
						"          WOGROUP as string,",
						"          PERSON_GROUP as string,",
						"          CAL_PMDUEDT as timestamp,",
						"          WORKTYPE_CM_PM as string,",
						"          REPORTMONTH_YEAR as string,",
						"          REPORTDATE_MONTH as string,",
						"          REPORTDATE_CM_PM as timestamp,",
						"          PLUSCFREQUENCY as integer,",
						"          PLUSCFREQUNIT as string,",
						"          PMNEXTDUEDATE as date,",
						"          PMNUM as string,",
						"          AVAILABLE_MANHOUR as integer,",
						"          PARENT_ACTLABHRS as decimal(18,9),",
						"          SNAPSHOT_DATE as timestamp,",
						"          CURRENT_RECORD_IND as integer,",
						"          EFFECTIVE_DT as timestamp,",
						"          STATUS_FLAG as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['OPERATION_ID'],",
						"     format: 'table',",
						"     staged: true,",
						"     allowCopyCommand: true,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     saveOrder: 1,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          OPERATION_ID = ExistOPERATION_ID,",
						"          CURRENT_RECORD_IND = NewCURRENT_RECORD_IND",
						"     )) ~> sinkOperationUpdate"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/dp_OpsSmry_df')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd",
								"type": "DatasetReference"
							},
							"name": "srcOpsSmryRd"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd",
								"type": "DatasetReference"
							},
							"name": "ExistingRows"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd",
								"type": "DatasetReference"
							},
							"name": "MaxSKey"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd",
								"type": "DatasetReference"
							},
							"name": "LocationRefRd"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "sinkOperationSmryLd",
								"type": "DatasetReference"
							},
							"name": "sinkOpsSmryLdInsert"
						},
						{
							"dataset": {
								"referenceName": "sinkOperationSmryLd",
								"type": "DatasetReference"
							},
							"name": "sinkOpsSmryUpdate"
						}
					],
					"transformations": [
						{
							"name": "dcOpsSmry"
						},
						{
							"name": "SKOpsSmry"
						},
						{
							"name": "dcWoAge"
						},
						{
							"name": "dcISbacklog"
						},
						{
							"name": "selOpsSmry"
						},
						{
							"name": "dcNewHashKey"
						},
						{
							"name": "existsOpsSmry"
						},
						{
							"name": "lookupOpsSmry"
						},
						{
							"name": "splitOpsSmry"
						},
						{
							"name": "joinMaxSK"
						},
						{
							"name": "dcInsertItem"
						},
						{
							"name": "alterRowInsert"
						},
						{
							"name": "joinLocation"
						},
						{
							"name": "selOpsSmryUpdate"
						},
						{
							"name": "alterRowUpdate"
						},
						{
							"name": "dcOpsSmryUpdate"
						}
					],
					"scriptLines": [
						"source(output(",
						"          WORK_ORDER as string,",
						"          GOVT_WO as string,",
						"          ORGANIZATION_ID as integer,",
						"          SITE_ID as integer,",
						"          DESCRIPTION as string,",
						"          LOCATION_ID as integer,",
						"          ASSET as string,",
						"          ASSET_ID as integer,",
						"          REPORTED_DATE as timestamp,",
						"          PRIORITY as string,",
						"          STATUS as string,",
						"          WO_STATUS_CHANGEDATE as timestamp,",
						"          TARGET_START_DT as timestamp,",
						"          TARGET_FINISH_DT as timestamp,",
						"          WORK_GROUP as string,",
						"          WORK_TYPE as string,",
						"          PM_DUE_DT as timestamp,",
						"          SITE as string,",
						"          WORKTYPE_CM_PM as string,",
						"          PERSON_GROUP_ID as integer,",
						"          SNAPSHOT_DT as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT WONUM AS WORK_ORDER,GOVTWONUM AS GOVT_WO,OPS.ORGANIZATION_ID AS ORGANIZATION_ID,OPS.SITE_ID AS SITE_ID,OPS.DESCRIPTION AS DESCRIPTION,OPS.LOCATION_ID AS LOCATION_ID,\\nISNULL(A.ASSETNUM,\\'NA\\') AS ASSET,\\nOPS.ASSET_ID AS ASSET_ID,\\nREPORTDATE AS REPORTED_DATE,WOPRIORITY AS PRIORITY,STATUS,WO_STATUS_CHANGEDATE,TARGSTARTDATE AS TARGET_START_DT,\\nTARGCOMPDATE AS TARGET_FINISH_DT,PERSON_GROUP AS WORK_GROUP,WORKTYPE AS WORK_TYPE,PMDUEDATE AS PM_DUE_DT,\\nS.SITE_NM AS SITE,OPS.WORKTYPE_CM_PM AS WORKTYPE_CM_PM,OPS.PERSON_GROUP_ID AS PERSON_GROUP_ID,OPS.SNAPSHOT_DATE AS SNAPSHOT_DT\\nFROM\\nMXMDW.OPERATION OPS INNER JOIN MXMDW.SITE S\\nON S.SITE_ID=OPS.SITE_ID\\nAND OPS.ISTASK = 0\\nAND OPS.CURRENT_RECORD_IND=1\\n--AND OPS.EFFECTIVE_DT>= CONVERT (DATE, SYSDATETIME())\\nAND OPS.EFFECTIVE_DT= (SELECT MAX(EFFECTIVE_DT) FROM MXMDW.OPERATION)\\nLEFT OUTER JOIN MXMDW.ASSET A\\nON A.ASSET_ID=OPS.ASSET_ID\\n',",
						"     format: 'query',",
						"     staged: true) ~> srcOpsSmryRd",
						"source(output(",
						"          ExistOPERATION_SUMMARY_ID as integer,",
						"          ExistWORK_ORDER as string,",
						"          ExistSITE as string,",
						"          ExistSRC_TYPE_HASH_KEY as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT OPERATION_SUMMARY_ID AS ExistOPERATION_SUMMARY_ID,WORK_ORDER AS ExistWORK_ORDER,SITE AS ExistSITE,SRC_TYPE_HASH_KEY AS ExistSRC_TYPE_HASH_KEY FROM MXMDM.OPERATION_SUMMARY',",
						"     format: 'query',",
						"     staged: true) ~> ExistingRows",
						"source(output(",
						"          MAXKEY as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT MAXKEY=ISNULL(MAX(OPERATION_SUMMARY_ID),0) FROM MXMDM.OPERATION_SUMMARY',",
						"     format: 'query',",
						"     staged: true) ~> MaxSKey",
						"source(output(",
						"          RefLOCATION_ID as integer,",
						"          LOCATION as string,",
						"          RefSITE_ID as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT LOCATION_ID AS RefLOCATION_ID,LOCATION,SITE_ID AS RefSITE_ID FROM MXMDW.LOCATIONS',",
						"     format: 'query',",
						"     staged: true) ~> LocationRefRd",
						"joinLocation derive(WO_OPEN_DT = REPORTED_DATE,",
						"          WO_DUE_DT = case(\r",
						"(PRIORITY == \"1\"), addDays(REPORTED_DATE,1),\r",
						"(PRIORITY == \"2\"), addDays(REPORTED_DATE,7),\r",
						"(PRIORITY == \"3\"), addDays(REPORTED_DATE,30),\r",
						"(PRIORITY == \"4\" && WORKTYPE_CM_PM ==\"CM\"), addDays(REPORTED_DATE,90),\r",
						"(PRIORITY == \"4\" && WORKTYPE_CM_PM ==\"PM\"), addDays(REPORTED_DATE,45),\r",
						"REPORTED_DATE\r",
						"),",
						"          WO_PRIORITY_THRESHOLD_DAYS = case(\r",
						"    (PRIORITY == \"1\"), 1,\r",
						"    (PRIORITY == \"2\"), 7,\r",
						"    (PRIORITY == \"3\"), 30,\r",
						"    (PRIORITY == \"4\" && WORKTYPE_CM_PM==\"CM\"), 90,\r",
						"     (PRIORITY == \"4\" && WORKTYPE_CM_PM==\"PM\"), 45,\r",
						"     0\r",
						"),",
						"          WO_CLOSE_DT = case\r",
						"(\r",
						"    (STATUS == 'CLOSE' || STATUS =='CAN' || STATUS == 'READY' || STATUS == 'COMP'), WO_STATUS_CHANGEDATE, currentTimestamp()\r",
						"    ),",
						"          PRIORITY = toInteger(PRIORITY),",
						"          PM_DUE_DT = iifNull(PM_DUE_DT, TARGET_START_DT, REPORTED_DATE)) ~> dcOpsSmry",
						"joinMaxSK keyGenerate(output(NewOPERATION_SUMMARY_ID as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> SKOpsSmry",
						"dcOpsSmry derive(WO_CLOSE_DT = iifNull(WO_CLOSE_DT, currentTimestamp(), WO_CLOSE_DT),",
						"          WO_AGE = toInteger( (currentTimestamp() - REPORTED_DATE)/86400000 )) ~> dcWoAge",
						"dcWoAge derive(IS_BACKLOG = case\r",
						"(\r",
						"    (WO_CLOSE_DT > WO_DUE_DT), 'Yes',\r",
						"     (WO_CLOSE_DT <= WO_DUE_DT), 'No',\r",
						"     'Yes' ),",
						"          WO_AGE_SEGMENT = case\r",
						"(\r",
						"    (WO_AGE >=0 && WO_AGE <= 30), '0-30 Days',\r",
						"     (WO_AGE >=31 && WO_AGE <= 45), '31-45 Days',\r",
						"     (WO_AGE >=46 && WO_AGE <= 60), '46-60 Days',\r",
						"     (WO_AGE >=61 && WO_AGE <= 90), '61-90 Days',\r",
						"     'Above 90 Days' \r",
						"     )) ~> dcISbacklog",
						"dcNewHashKey select(mapColumn(",
						"          WORK_ORDER,",
						"          GOVT_WO,",
						"          DESCRIPTION,",
						"          LOCATION_ID,",
						"          LOCATION,",
						"          ASSET,",
						"          REPORTED_DATE,",
						"          PRIORITY,",
						"          WO_STATUS_CHANGEDATE,",
						"          STATUS,",
						"          TARGET_START_DT,",
						"          TARGET_FINISH_DT,",
						"          WORK_GROUP,",
						"          WORK_TYPE,",
						"          PM_DUE_DT,",
						"          SITE,",
						"          SITE_ID,",
						"          WORKTYPE_CM_PM,",
						"          PERSON_GROUP_ID,",
						"          WO_OPEN_DT,",
						"          WO_DUE_DT,",
						"          WO_PRIORITY_THRESHOLD_DAYS,",
						"          WO_CLOSE_DT,",
						"          WO_AGE,",
						"          IS_BACKLOG,",
						"          WO_AGE_SEGMENT,",
						"          SRC_TYPE_HASH_KEY,",
						"          SNAPSHOT_DT",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selOpsSmry",
						"dcISbacklog derive(SRC_TYPE_HASH_KEY = sha2(256,WORK_ORDER,SITE,WO_CLOSE_DT,WO_AGE,WO_AGE_SEGMENT,IS_BACKLOG)) ~> dcNewHashKey",
						"selOpsSmry, ExistingRows exists(SRC_TYPE_HASH_KEY == ExistSRC_TYPE_HASH_KEY",
						"     && WORK_ORDER == ExistWORK_ORDER",
						"     && SITE == ExistSITE,",
						"     negate:true,",
						"     partitionBy('hash', 4,",
						"          WORK_ORDER,",
						"          SITE",
						"     ),",
						"     broadcast: 'right')~> existsOpsSmry",
						"existsOpsSmry, ExistingRows lookup(WORK_ORDER == ExistWORK_ORDER",
						"     && SITE == ExistSITE,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lookupOpsSmry",
						"lookupOpsSmry split(isNull(ExistOPERATION_SUMMARY_ID),",
						"     disjoint: false) ~> splitOpsSmry@(NewItem, UpdateItem)",
						"splitOpsSmry@NewItem, MaxSKey join(1==1,",
						"     joinType:'cross',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinMaxSK",
						"SKOpsSmry derive(NewOPERATION_SUMMARY_ID = NewOPERATION_SUMMARY_ID + MAXKEY,",
						"          ACTLABHRS = toDecimal(0.00),",
						"          EFFECTIVE_DT = currentTimestamp()) ~> dcInsertItem",
						"dcInsertItem alterRow(insertIf(1==1)) ~> alterRowInsert",
						"srcOpsSmryRd, LocationRefRd join(LOCATION_ID == RefLOCATION_ID",
						"     && SITE_ID == RefSITE_ID,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinLocation",
						"splitOpsSmry@UpdateItem select(mapColumn(",
						"          WORK_ORDER,",
						"          GOVT_WO,",
						"          DESCRIPTION,",
						"          LOCATION_ID,",
						"          LOCATION,",
						"          ASSET,",
						"          REPORTED_DATE,",
						"          PRIORITY,",
						"          WO_STATUS_CHANGEDATE,",
						"          STATUS,",
						"          TARGET_START_DT,",
						"          TARGET_FINISH_DT,",
						"          WORK_GROUP,",
						"          WORK_TYPE,",
						"          PM_DUE_DT,",
						"          SITE,",
						"          SITE_ID,",
						"          WORKTYPE_CM_PM,",
						"          PERSON_GROUP_ID,",
						"          WO_OPEN_DT,",
						"          WO_DUE_DT,",
						"          WO_PRIORITY_THRESHOLD_DAYS,",
						"          WO_CLOSE_DT,",
						"          WO_AGE,",
						"          IS_BACKLOG,",
						"          WO_AGE_SEGMENT,",
						"          SRC_TYPE_HASH_KEY,",
						"          SNAPSHOT_DT,",
						"          ExistOPERATION_SUMMARY_ID,",
						"          ExistWORK_ORDER,",
						"          ExistSITE,",
						"          ExistSRC_TYPE_HASH_KEY",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selOpsSmryUpdate",
						"dcOpsSmryUpdate alterRow(updateIf(1==1)) ~> alterRowUpdate",
						"selOpsSmryUpdate derive(EFFECTIVE_DT = currentTimestamp()) ~> dcOpsSmryUpdate",
						"alterRowInsert sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          OPERATION_SUMMARY_ID as integer,",
						"          WORK_ORDER as string,",
						"          GOVT_WO as string,",
						"          DESCRIPTION as string,",
						"          SITE_ID as integer,",
						"          LOCATION_ID as integer,",
						"          LOCATION as string,",
						"          ASSET as string,",
						"          REPORTED_DATE as timestamp,",
						"          PRIORITY as integer,",
						"          STATUS as string,",
						"          WO_STATUS_CHANGEDATE as timestamp,",
						"          TARGET_START_DT as timestamp,",
						"          TARGET_FINISH_DT as timestamp,",
						"          ACTLABHRS as decimal(18,9),",
						"          WORK_GROUP as string,",
						"          WORK_TYPE as string,",
						"          PM_DUE_DT as timestamp,",
						"          SITE as string,",
						"          WO_OPEN_DT as timestamp,",
						"          WO_DUE_DT as timestamp,",
						"          WO_PRIORITY_THRESHOLD_DAYS as integer,",
						"          WO_CLOSE_DT as timestamp,",
						"          WO_AGE as decimal(18,4),",
						"          WO_AGE_SEGMENT as string,",
						"          WORK_TYPE_CM_PM as string,",
						"          PERSON_GROUP_ID as integer,",
						"          IS_BACKLOG as string,",
						"          SNAPSHOT_DT as timestamp,",
						"          SRC_TYPE_HASH_KEY as string,",
						"          EFFECTIVE_DT as timestamp",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     staged: true,",
						"     allowCopyCommand: true,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     saveOrder: 2,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          OPERATION_SUMMARY_ID = NewOPERATION_SUMMARY_ID,",
						"          WORK_ORDER,",
						"          GOVT_WO,",
						"          DESCRIPTION,",
						"          SITE_ID,",
						"          LOCATION_ID,",
						"          LOCATION,",
						"          ASSET,",
						"          REPORTED_DATE,",
						"          WO_STATUS_CHANGEDATE,",
						"          PRIORITY,",
						"          STATUS,",
						"          TARGET_START_DT,",
						"          TARGET_FINISH_DT,",
						"          ACTLABHRS,",
						"          WORK_GROUP,",
						"          WORK_TYPE,",
						"          WORK_TYPE_CM_PM = WORKTYPE_CM_PM,",
						"          PM_DUE_DT,",
						"          SITE,",
						"          WO_OPEN_DT,",
						"          WO_DUE_DT,",
						"          WO_PRIORITY_THRESHOLD_DAYS,",
						"          WO_CLOSE_DT,",
						"          IS_BACKLOG,",
						"          WO_AGE,",
						"          WO_AGE_SEGMENT,",
						"          PERSON_GROUP_ID,",
						"          SRC_TYPE_HASH_KEY,",
						"          SNAPSHOT_DT,",
						"          EFFECTIVE_DT",
						"     )) ~> sinkOpsSmryLdInsert",
						"alterRowUpdate sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          OPERATION_SUMMARY_ID as integer,",
						"          WORK_ORDER as string,",
						"          GOVT_WO as string,",
						"          DESCRIPTION as string,",
						"          SITE_ID as integer,",
						"          LOCATION_ID as integer,",
						"          LOCATION as string,",
						"          ASSET as string,",
						"          REPORTED_DATE as timestamp,",
						"          PRIORITY as integer,",
						"          STATUS as string,",
						"          WO_STATUS_CHANGEDATE as timestamp,",
						"          TARGET_START_DT as timestamp,",
						"          TARGET_FINISH_DT as timestamp,",
						"          ACTLABHRS as decimal(18,9),",
						"          WORK_GROUP as string,",
						"          WORK_TYPE as string,",
						"          PM_DUE_DT as timestamp,",
						"          SITE as string,",
						"          WO_OPEN_DT as timestamp,",
						"          WO_DUE_DT as timestamp,",
						"          WO_PRIORITY_THRESHOLD_DAYS as integer,",
						"          WO_CLOSE_DT as timestamp,",
						"          WO_AGE as decimal(18,4),",
						"          WO_AGE_SEGMENT as string,",
						"          WORK_TYPE_CM_PM as string,",
						"          PERSON_GROUP_ID as integer,",
						"          IS_BACKLOG as string,",
						"          SNAPSHOT_DT as timestamp,",
						"          SRC_TYPE_HASH_KEY as string,",
						"          EFFECTIVE_DT as timestamp",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['OPERATION_SUMMARY_ID'],",
						"     format: 'table',",
						"     staged: true,",
						"     allowCopyCommand: true,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     saveOrder: 1,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          OPERATION_SUMMARY_ID = ExistOPERATION_SUMMARY_ID,",
						"          WORK_ORDER = ExistWORK_ORDER,",
						"          SITE = ExistSITE,",
						"          GOVT_WO,",
						"          DESCRIPTION,",
						"          SITE_ID,",
						"          LOCATION_ID,",
						"          LOCATION,",
						"          ASSET,",
						"          REPORTED_DATE,",
						"          PRIORITY,",
						"          STATUS,",
						"          WO_STATUS_CHANGEDATE,",
						"          TARGET_START_DT,",
						"          TARGET_FINISH_DT,",
						"          WORK_GROUP,",
						"          WORK_TYPE,",
						"          PM_DUE_DT,",
						"          WO_OPEN_DT,",
						"          WO_DUE_DT,",
						"          WO_PRIORITY_THRESHOLD_DAYS,",
						"          WO_CLOSE_DT,",
						"          WO_AGE,",
						"          WO_AGE_SEGMENT,",
						"          WORK_TYPE_CM_PM = WORKTYPE_CM_PM,",
						"          PERSON_GROUP_ID,",
						"          IS_BACKLOG,",
						"          SNAPSHOT_DT,",
						"          SRC_TYPE_HASH_KEY,",
						"          EFFECTIVE_DT",
						"     )) ~> sinkOpsSmryUpdate"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/dp_OpsSmry_df1')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd7",
								"type": "DatasetReference"
							},
							"name": "srcOpsSmryRd"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd7",
								"type": "DatasetReference"
							},
							"name": "ExistingRows"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd7",
								"type": "DatasetReference"
							},
							"name": "MaxSKey"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd7",
								"type": "DatasetReference"
							},
							"name": "LocationRefRd"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "sinkOperationSmryLd1",
								"type": "DatasetReference"
							},
							"name": "sinkOpsSmryLdInsert"
						},
						{
							"dataset": {
								"referenceName": "sinkOperationSmryLd1",
								"type": "DatasetReference"
							},
							"name": "sinkOpsSmryUpdate"
						}
					],
					"transformations": [
						{
							"name": "dcOpsSmry"
						},
						{
							"name": "SKOpsSmry"
						},
						{
							"name": "dcWoAge"
						},
						{
							"name": "dcISbacklog"
						},
						{
							"name": "selOpsSmry"
						},
						{
							"name": "dcNewHashKey"
						},
						{
							"name": "existsOpsSmry"
						},
						{
							"name": "lookupOpsSmry"
						},
						{
							"name": "splitOpsSmry"
						},
						{
							"name": "joinMaxSK"
						},
						{
							"name": "dcInsertItem"
						},
						{
							"name": "alterRowInsert"
						},
						{
							"name": "joinLocation"
						},
						{
							"name": "selOpsSmryUpdate"
						},
						{
							"name": "alterRowUpdate"
						},
						{
							"name": "dcOpsSmryUpdate"
						}
					],
					"scriptLines": [
						"source(output(",
						"          WORK_ORDER as string,",
						"          GOVT_WO as string,",
						"          ORGANIZATION_ID as integer,",
						"          SITE_ID as integer,",
						"          DESCRIPTION as string,",
						"          LOCATION_ID as integer,",
						"          ASSET as string,",
						"          ASSET_ID as integer,",
						"          REPORTED_DATE as timestamp,",
						"          PRIORITY as string,",
						"          STATUS as string,",
						"          WO_STATUS_CHANGEDATE as timestamp,",
						"          TARGET_START_DT as timestamp,",
						"          TARGET_FINISH_DT as timestamp,",
						"          WORK_GROUP as string,",
						"          WORK_TYPE as string,",
						"          PM_DUE_DT as timestamp,",
						"          SITE as string,",
						"          WORKTYPE_CM_PM as string,",
						"          PERSON_GROUP_ID as integer,",
						"          SNAPSHOT_DT as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT WONUM AS WORK_ORDER,GOVTWONUM AS GOVT_WO,OPS.ORGANIZATION_ID AS ORGANIZATION_ID,OPS.SITE_ID AS SITE_ID,OPS.DESCRIPTION AS DESCRIPTION,OPS.LOCATION_ID AS LOCATION_ID,\\nISNULL(A.ASSETNUM,\\'NA\\') AS ASSET,\\nOPS.ASSET_ID AS ASSET_ID,\\nREPORTDATE AS REPORTED_DATE,WOPRIORITY AS PRIORITY,STATUS,WO_STATUS_CHANGEDATE,TARGSTARTDATE AS TARGET_START_DT,\\nTARGCOMPDATE AS TARGET_FINISH_DT,PERSON_GROUP AS WORK_GROUP,WORKTYPE AS WORK_TYPE,PMDUEDATE AS PM_DUE_DT,\\nS.SITE_NM AS SITE,OPS.WORKTYPE_CM_PM AS WORKTYPE_CM_PM,OPS.PERSON_GROUP_ID AS PERSON_GROUP_ID,OPS.SNAPSHOT_DATE AS SNAPSHOT_DT\\nFROM\\nMXMDW.OPERATION OPS INNER JOIN MXMDW.SITE S\\nON S.SITE_ID=OPS.SITE_ID\\nAND OPS.ISTASK = 0\\nAND OPS.CURRENT_RECORD_IND=1\\n--AND OPS.EFFECTIVE_DT>= CONVERT (DATE, SYSDATETIME())\\nAND OPS.EFFECTIVE_DT= (SELECT MAX(EFFECTIVE_DT) FROM MXMDW.OPERATION)\\nLEFT OUTER JOIN MXMDW.ASSET A\\nON A.ASSET_ID=OPS.ASSET_ID\\n',",
						"     format: 'query',",
						"     staged: true) ~> srcOpsSmryRd",
						"source(output(",
						"          ExistOPERATION_SUMMARY_ID as integer,",
						"          ExistWORK_ORDER as string,",
						"          ExistSITE as string,",
						"          ExistSRC_TYPE_HASH_KEY as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT OPERATION_SUMMARY_ID AS ExistOPERATION_SUMMARY_ID,WORK_ORDER AS ExistWORK_ORDER,SITE AS ExistSITE,SRC_TYPE_HASH_KEY AS ExistSRC_TYPE_HASH_KEY FROM MXMDM.OPERATION_SUMMARY',",
						"     format: 'query',",
						"     staged: true) ~> ExistingRows",
						"source(output(",
						"          MAXKEY as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT MAXKEY=ISNULL(MAX(OPERATION_SUMMARY_ID),0) FROM MXMDM.OPERATION_SUMMARY',",
						"     format: 'query',",
						"     staged: true) ~> MaxSKey",
						"source(output(",
						"          RefLOCATION_ID as integer,",
						"          LOCATION as string,",
						"          RefSITE_ID as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT LOCATION_ID AS RefLOCATION_ID,LOCATION,SITE_ID AS RefSITE_ID FROM MXMDW.LOCATIONS',",
						"     format: 'query',",
						"     staged: true) ~> LocationRefRd",
						"joinLocation derive(WO_OPEN_DT = REPORTED_DATE,",
						"          WO_DUE_DT = case(\r",
						"(PRIORITY == \"1\"), addDays(REPORTED_DATE,1),\r",
						"(PRIORITY == \"2\"), addDays(REPORTED_DATE,7),\r",
						"(PRIORITY == \"3\"), addDays(REPORTED_DATE,30),\r",
						"(PRIORITY == \"4\" && WORKTYPE_CM_PM ==\"CM\"), addDays(REPORTED_DATE,90),\r",
						"(PRIORITY == \"4\" && WORKTYPE_CM_PM ==\"PM\"), addDays(REPORTED_DATE,45),\r",
						"REPORTED_DATE\r",
						"),",
						"          WO_PRIORITY_THRESHOLD_DAYS = case(\r",
						"    (PRIORITY == \"1\"), 1,\r",
						"    (PRIORITY == \"2\"), 7,\r",
						"    (PRIORITY == \"3\"), 30,\r",
						"    (PRIORITY == \"4\" && WORKTYPE_CM_PM==\"CM\"), 90,\r",
						"     (PRIORITY == \"4\" && WORKTYPE_CM_PM==\"PM\"), 45,\r",
						"     0\r",
						"),",
						"          WO_CLOSE_DT = case\r",
						"(\r",
						"    (STATUS == 'CLOSE' || STATUS =='CAN' || STATUS == 'READY' || STATUS == 'COMP'), WO_STATUS_CHANGEDATE, currentTimestamp()\r",
						"    ),",
						"          PRIORITY = toInteger(PRIORITY),",
						"          PM_DUE_DT = iifNull(PM_DUE_DT, TARGET_START_DT, REPORTED_DATE)) ~> dcOpsSmry",
						"joinMaxSK keyGenerate(output(NewOPERATION_SUMMARY_ID as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> SKOpsSmry",
						"dcOpsSmry derive(WO_CLOSE_DT = iifNull(WO_CLOSE_DT, currentTimestamp(), WO_CLOSE_DT),",
						"          WO_AGE = toInteger( (currentTimestamp() - REPORTED_DATE)/86400000 )) ~> dcWoAge",
						"dcWoAge derive(IS_BACKLOG = case\r",
						"(\r",
						"    (WO_CLOSE_DT > WO_DUE_DT), 'Yes',\r",
						"     (WO_CLOSE_DT <= WO_DUE_DT), 'No',\r",
						"     'Yes' ),",
						"          WO_AGE_SEGMENT = case\r",
						"(\r",
						"    (WO_AGE >=0 && WO_AGE <= 30), '0-30 Days',\r",
						"     (WO_AGE >=31 && WO_AGE <= 45), '31-45 Days',\r",
						"     (WO_AGE >=46 && WO_AGE <= 60), '46-60 Days',\r",
						"     (WO_AGE >=61 && WO_AGE <= 90), '61-90 Days',\r",
						"     'Above 90 Days' \r",
						"     )) ~> dcISbacklog",
						"dcNewHashKey select(mapColumn(",
						"          WORK_ORDER,",
						"          GOVT_WO,",
						"          DESCRIPTION,",
						"          LOCATION_ID,",
						"          LOCATION,",
						"          ASSET,",
						"          REPORTED_DATE,",
						"          PRIORITY,",
						"          WO_STATUS_CHANGEDATE,",
						"          STATUS,",
						"          TARGET_START_DT,",
						"          TARGET_FINISH_DT,",
						"          WORK_GROUP,",
						"          WORK_TYPE,",
						"          PM_DUE_DT,",
						"          SITE,",
						"          SITE_ID,",
						"          WORKTYPE_CM_PM,",
						"          PERSON_GROUP_ID,",
						"          WO_OPEN_DT,",
						"          WO_DUE_DT,",
						"          WO_PRIORITY_THRESHOLD_DAYS,",
						"          WO_CLOSE_DT,",
						"          WO_AGE,",
						"          IS_BACKLOG,",
						"          WO_AGE_SEGMENT,",
						"          SRC_TYPE_HASH_KEY,",
						"          SNAPSHOT_DT",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selOpsSmry",
						"dcISbacklog derive(SRC_TYPE_HASH_KEY = sha2(256,WORK_ORDER,SITE,WO_CLOSE_DT,WO_AGE,WO_AGE_SEGMENT,IS_BACKLOG)) ~> dcNewHashKey",
						"selOpsSmry, ExistingRows exists(SRC_TYPE_HASH_KEY == ExistSRC_TYPE_HASH_KEY",
						"     && WORK_ORDER == ExistWORK_ORDER",
						"     && SITE == ExistSITE,",
						"     negate:true,",
						"     partitionBy('hash', 4,",
						"          WORK_ORDER,",
						"          SITE",
						"     ),",
						"     broadcast: 'right')~> existsOpsSmry",
						"existsOpsSmry, ExistingRows lookup(WORK_ORDER == ExistWORK_ORDER",
						"     && SITE == ExistSITE,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lookupOpsSmry",
						"lookupOpsSmry split(isNull(ExistOPERATION_SUMMARY_ID),",
						"     disjoint: false) ~> splitOpsSmry@(NewItem, UpdateItem)",
						"splitOpsSmry@NewItem, MaxSKey join(1==1,",
						"     joinType:'cross',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinMaxSK",
						"SKOpsSmry derive(NewOPERATION_SUMMARY_ID = NewOPERATION_SUMMARY_ID + MAXKEY,",
						"          ACTLABHRS = toDecimal(0.00),",
						"          EFFECTIVE_DT = currentTimestamp()) ~> dcInsertItem",
						"dcInsertItem alterRow(insertIf(1==1)) ~> alterRowInsert",
						"srcOpsSmryRd, LocationRefRd join(LOCATION_ID == RefLOCATION_ID",
						"     && SITE_ID == RefSITE_ID,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinLocation",
						"splitOpsSmry@UpdateItem select(mapColumn(",
						"          WORK_ORDER,",
						"          GOVT_WO,",
						"          DESCRIPTION,",
						"          LOCATION_ID,",
						"          LOCATION,",
						"          ASSET,",
						"          REPORTED_DATE,",
						"          PRIORITY,",
						"          WO_STATUS_CHANGEDATE,",
						"          STATUS,",
						"          TARGET_START_DT,",
						"          TARGET_FINISH_DT,",
						"          WORK_GROUP,",
						"          WORK_TYPE,",
						"          PM_DUE_DT,",
						"          SITE,",
						"          SITE_ID,",
						"          WORKTYPE_CM_PM,",
						"          PERSON_GROUP_ID,",
						"          WO_OPEN_DT,",
						"          WO_DUE_DT,",
						"          WO_PRIORITY_THRESHOLD_DAYS,",
						"          WO_CLOSE_DT,",
						"          WO_AGE,",
						"          IS_BACKLOG,",
						"          WO_AGE_SEGMENT,",
						"          SRC_TYPE_HASH_KEY,",
						"          SNAPSHOT_DT,",
						"          ExistOPERATION_SUMMARY_ID,",
						"          ExistWORK_ORDER,",
						"          ExistSITE,",
						"          ExistSRC_TYPE_HASH_KEY",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selOpsSmryUpdate",
						"dcOpsSmryUpdate alterRow(updateIf(1==1)) ~> alterRowUpdate",
						"selOpsSmryUpdate derive(EFFECTIVE_DT = currentTimestamp()) ~> dcOpsSmryUpdate",
						"alterRowInsert sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          OPERATION_SUMMARY_ID as integer,",
						"          WORK_ORDER as string,",
						"          GOVT_WO as string,",
						"          DESCRIPTION as string,",
						"          SITE_ID as integer,",
						"          LOCATION_ID as integer,",
						"          LOCATION as string,",
						"          ASSET as string,",
						"          REPORTED_DATE as timestamp,",
						"          PRIORITY as integer,",
						"          STATUS as string,",
						"          WO_STATUS_CHANGEDATE as timestamp,",
						"          TARGET_START_DT as timestamp,",
						"          TARGET_FINISH_DT as timestamp,",
						"          ACTLABHRS as decimal(18,9),",
						"          WORK_GROUP as string,",
						"          WORK_TYPE as string,",
						"          PM_DUE_DT as timestamp,",
						"          SITE as string,",
						"          WO_OPEN_DT as timestamp,",
						"          WO_DUE_DT as timestamp,",
						"          WO_PRIORITY_THRESHOLD_DAYS as integer,",
						"          WO_CLOSE_DT as timestamp,",
						"          WO_AGE as decimal(18,4),",
						"          WO_AGE_SEGMENT as string,",
						"          WORK_TYPE_CM_PM as string,",
						"          PERSON_GROUP_ID as integer,",
						"          IS_BACKLOG as string,",
						"          SNAPSHOT_DT as timestamp,",
						"          SRC_TYPE_HASH_KEY as string,",
						"          EFFECTIVE_DT as timestamp",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     staged: true,",
						"     allowCopyCommand: true,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     saveOrder: 2,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          OPERATION_SUMMARY_ID = NewOPERATION_SUMMARY_ID,",
						"          WORK_ORDER,",
						"          GOVT_WO,",
						"          DESCRIPTION,",
						"          SITE_ID,",
						"          LOCATION_ID,",
						"          LOCATION,",
						"          ASSET,",
						"          REPORTED_DATE,",
						"          WO_STATUS_CHANGEDATE,",
						"          PRIORITY,",
						"          STATUS,",
						"          TARGET_START_DT,",
						"          TARGET_FINISH_DT,",
						"          ACTLABHRS,",
						"          WORK_GROUP,",
						"          WORK_TYPE,",
						"          WORK_TYPE_CM_PM = WORKTYPE_CM_PM,",
						"          PM_DUE_DT,",
						"          SITE,",
						"          WO_OPEN_DT,",
						"          WO_DUE_DT,",
						"          WO_PRIORITY_THRESHOLD_DAYS,",
						"          WO_CLOSE_DT,",
						"          IS_BACKLOG,",
						"          WO_AGE,",
						"          WO_AGE_SEGMENT,",
						"          PERSON_GROUP_ID,",
						"          SRC_TYPE_HASH_KEY,",
						"          SNAPSHOT_DT,",
						"          EFFECTIVE_DT",
						"     )) ~> sinkOpsSmryLdInsert",
						"alterRowUpdate sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          OPERATION_SUMMARY_ID as integer,",
						"          WORK_ORDER as string,",
						"          GOVT_WO as string,",
						"          DESCRIPTION as string,",
						"          SITE_ID as integer,",
						"          LOCATION_ID as integer,",
						"          LOCATION as string,",
						"          ASSET as string,",
						"          REPORTED_DATE as timestamp,",
						"          PRIORITY as integer,",
						"          STATUS as string,",
						"          WO_STATUS_CHANGEDATE as timestamp,",
						"          TARGET_START_DT as timestamp,",
						"          TARGET_FINISH_DT as timestamp,",
						"          ACTLABHRS as decimal(18,9),",
						"          WORK_GROUP as string,",
						"          WORK_TYPE as string,",
						"          PM_DUE_DT as timestamp,",
						"          SITE as string,",
						"          WO_OPEN_DT as timestamp,",
						"          WO_DUE_DT as timestamp,",
						"          WO_PRIORITY_THRESHOLD_DAYS as integer,",
						"          WO_CLOSE_DT as timestamp,",
						"          WO_AGE as decimal(18,4),",
						"          WO_AGE_SEGMENT as string,",
						"          WORK_TYPE_CM_PM as string,",
						"          PERSON_GROUP_ID as integer,",
						"          IS_BACKLOG as string,",
						"          SNAPSHOT_DT as timestamp,",
						"          SRC_TYPE_HASH_KEY as string,",
						"          EFFECTIVE_DT as timestamp",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['OPERATION_SUMMARY_ID'],",
						"     format: 'table',",
						"     staged: true,",
						"     allowCopyCommand: true,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     saveOrder: 1,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          OPERATION_SUMMARY_ID = ExistOPERATION_SUMMARY_ID,",
						"          WORK_ORDER = ExistWORK_ORDER,",
						"          SITE = ExistSITE,",
						"          GOVT_WO,",
						"          DESCRIPTION,",
						"          SITE_ID,",
						"          LOCATION_ID,",
						"          LOCATION,",
						"          ASSET,",
						"          REPORTED_DATE,",
						"          PRIORITY,",
						"          STATUS,",
						"          WO_STATUS_CHANGEDATE,",
						"          TARGET_START_DT,",
						"          TARGET_FINISH_DT,",
						"          WORK_GROUP,",
						"          WORK_TYPE,",
						"          PM_DUE_DT,",
						"          WO_OPEN_DT,",
						"          WO_DUE_DT,",
						"          WO_PRIORITY_THRESHOLD_DAYS,",
						"          WO_CLOSE_DT,",
						"          WO_AGE,",
						"          WO_AGE_SEGMENT,",
						"          WORK_TYPE_CM_PM = WORKTYPE_CM_PM,",
						"          PERSON_GROUP_ID,",
						"          IS_BACKLOG,",
						"          SNAPSHOT_DT,",
						"          SRC_TYPE_HASH_KEY,",
						"          EFFECTIVE_DT",
						"     )) ~> sinkOpsSmryUpdate"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/dp_Person_Dim_df')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "AzureSynpMxmStgRefnAsset",
								"type": "DatasetReference"
							},
							"name": "srcPersonLd"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd",
								"type": "DatasetReference"
							},
							"name": "srcPersonSiteRefRd"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd",
								"type": "DatasetReference"
							},
							"name": "PersonExistRowRd"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd",
								"type": "DatasetReference"
							},
							"name": "MaxKey"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "SinkPersonInitialLoad",
								"type": "DatasetReference"
							},
							"name": "sinkPersonLd"
						},
						{
							"dataset": {
								"referenceName": "SinkPersonInitialLoad",
								"type": "DatasetReference"
							},
							"name": "sinkPersonUpdate"
						}
					],
					"transformations": [
						{
							"name": "dcPersonLd"
						},
						{
							"name": "skPersonLd"
						},
						{
							"name": "lkpPersonSite"
						},
						{
							"name": "selPersonExistRow"
						},
						{
							"name": "dcPersonHashKey"
						},
						{
							"name": "existsPerson"
						},
						{
							"name": "lookupPerson"
						},
						{
							"name": "splitPerson"
						},
						{
							"name": "joinPerson"
						},
						{
							"name": "dcPersonInsert"
						},
						{
							"name": "selPersonInsert"
						},
						{
							"name": "alterRowInsert"
						},
						{
							"name": "dcPersonUpdate"
						},
						{
							"name": "selPersonUpdate"
						},
						{
							"name": "alterRowUpdate"
						}
					],
					"scriptLines": [
						"source(output(",
						"          PERSON_NBR as string,",
						"          PERSON_FIRST_NM as string,",
						"          PERSON_LAST_NM as string,",
						"          STATUS as string,",
						"          DEPARTMENT as string,",
						"          TITLE as string,",
						"          EMPLOYEE_TYPE as string,",
						"          JOBCODE as string,",
						"          SUPERVISOR as string,",
						"          BIRTHDATE as date,",
						"          HIREDATE as date,",
						"          TERMINATIONDATE as date,",
						"          LOCATION as string,",
						"          LOCATIONSITE as string,",
						"          STATUSDATE as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: '\\nSELECT \\nPERSONID AS PERSON_NBR,\\nFIRSTNAME AS PERSON_FIRST_NM,\\nLASTNAME AS PERSON_LAST_NM,\\nSTATUS AS STATUS,\\nDEPARTMENT AS DEPARTMENT,\\nTITLE AS TITLE,\\nEMPLOYEETYPE AS EMPLOYEE_TYPE,\\nJOBCODE AS JOBCODE,\\nSUPERVISOR AS SUPERVISOR,\\nBIRTHDATE,\\nHIREDATE,\\nTERMINATIONDATE,\\nLOCATION,\\nLOCATIONSITE,\\nSTATUSDATE\\nFROM MXMSTG.STG_PERSON',",
						"     format: 'query',",
						"     staged: true) ~> srcPersonLd",
						"source(output(",
						"          SITE_ID as integer,",
						"          SITE_NM as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT SITE_ID,SITE_NM FROM MXMDW.SITE',",
						"     format: 'query',",
						"     staged: true) ~> srcPersonSiteRefRd",
						"source(output(",
						"          PERSON_ID as integer,",
						"          PERSON_NBR as string,",
						"          STATUS as string,",
						"          DEPARTMENT as string,",
						"          JOBCODE as string,",
						"          SUPERVISOR as string,",
						"          SRC_TYPE_HASH_KEY as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT PERSON_ID,PERSON_NBR,STATUS,DEPARTMENT,JOBCODE,SUPERVISOR,SRC_TYPE_HASH_KEY FROM MXMDW.PERSON',",
						"     format: 'query',",
						"     staged: true,",
						"     partitionBy('hash', 1)) ~> PersonExistRowRd",
						"source(output(",
						"          MAXKEY as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT MAXKEY=ISNULL(MAX(PERSON_ID),0) FROM MXMDW.PERSON',",
						"     format: 'query',",
						"     staged: true) ~> MaxKey",
						"lkpPersonSite derive(PERSON_FIRST_NM = iifNull(PERSON_FIRST_NM, 'NA', PERSON_FIRST_NM),",
						"          PERSON_LAST_NM = iifNull(PERSON_LAST_NM, 'NA', PERSON_LAST_NM),",
						"          STATUS = iifNull(STATUS, 'NA', STATUS),",
						"          DEPARTMENT = iifNull(DEPARTMENT, 'NA', DEPARTMENT),",
						"          TITLE = iifNull(TITLE, 'NA', TITLE),",
						"          EMPLOYEE_TYPE = iifNull(EMPLOYEE_TYPE, 'NA', EMPLOYEE_TYPE),",
						"          JOBCODE = iifNull(JOBCODE, 'NA', JOBCODE),",
						"          SUPERVISOR = iifNull(SUPERVISOR, 'NA', SUPERVISOR),",
						"          BIRTHDATE = iifNull(BIRTHDATE, toDate('1900/01/01','yyyy/MM/dd'), BIRTHDATE),",
						"          HIREDATE = iifNull(HIREDATE, toDate('1900/01/01','yyyy/MM/dd'), HIREDATE),",
						"          LOCATION = iifNull(LOCATION, 'NA', LOCATION)) ~> dcPersonLd",
						"joinPerson keyGenerate(output(NewPERSON_ID as long),",
						"     startAt: 1L,",
						"     stepValue: 1L,",
						"     partitionBy('hash', 1)) ~> skPersonLd",
						"srcPersonLd, srcPersonSiteRefRd lookup(LOCATIONSITE == SITE_NM,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lkpPersonSite",
						"PersonExistRowRd select(mapColumn(",
						"          ExistPERSON_ID = PERSON_ID,",
						"          ExistPERSON_NBR = PERSON_NBR,",
						"          ExistSTATUS = STATUS,",
						"          ExistDEPARTMENT = DEPARTMENT,",
						"          ExistJOBCODE = JOBCODE,",
						"          ExistSUPERVISOR = SUPERVISOR,",
						"          ExistSRC_TYPE_HASH_KEY = SRC_TYPE_HASH_KEY",
						"     ),",
						"     partitionBy('hash', 1),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selPersonExistRow",
						"dcPersonLd derive(SRC_TYPE_HASH_KEY = sha2(256,PERSON_NBR,STATUS,DEPARTMENT,JOBCODE,SUPERVISOR)) ~> dcPersonHashKey",
						"dcPersonHashKey, selPersonExistRow exists(PERSON_NBR == ExistPERSON_NBR",
						"     && STATUS == ExistSTATUS",
						"     && DEPARTMENT == ExistDEPARTMENT",
						"     && JOBCODE == ExistJOBCODE",
						"     && SUPERVISOR == ExistSUPERVISOR,",
						"     negate:true,",
						"     partitionBy('hash', 1),",
						"     broadcast: 'right')~> existsPerson",
						"existsPerson, selPersonExistRow lookup(PERSON_NBR == ExistPERSON_NBR,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     partitionBy('hash', 1),",
						"     broadcast: 'auto')~> lookupPerson",
						"lookupPerson split(isNull(ExistPERSON_ID),",
						"     disjoint: false,",
						"     partitionBy('hash', 1)) ~> splitPerson@(NewItem, UpdateItem)",
						"splitPerson@NewItem, MaxKey join(1==1,",
						"     joinType:'cross',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     partitionBy('hash', 1),",
						"     broadcast: 'auto')~> joinPerson",
						"skPersonLd derive(NewPERSON_ID = NewPERSON_ID + MAXKEY,",
						"          EFFECTIVE_DT = currentTimestamp()) ~> dcPersonInsert",
						"dcPersonInsert select(mapColumn(",
						"          PERSON_NBR,",
						"          PERSON_FIRST_NM,",
						"          PERSON_LAST_NM,",
						"          STATUS,",
						"          DEPARTMENT,",
						"          TITLE,",
						"          EMPLOYEE_TYPE,",
						"          JOBCODE,",
						"          SUPERVISOR,",
						"          BIRTHDATE,",
						"          HIREDATE,",
						"          TERMINATIONDATE,",
						"          LOCATION,",
						"          SITE_ID,",
						"          SRC_TYPE_HASH_KEY,",
						"          NewPERSON_ID,",
						"          EFFECTIVE_DT",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selPersonInsert",
						"selPersonInsert alterRow(insertIf(1==1)) ~> alterRowInsert",
						"selPersonUpdate derive(EFFECTIVE_DT = currentTimestamp()) ~> dcPersonUpdate",
						"splitPerson@UpdateItem select(mapColumn(",
						"          PERSON_FIRST_NM,",
						"          PERSON_NBR,",
						"          PERSON_LAST_NM,",
						"          STATUS,",
						"          DEPARTMENT,",
						"          TITLE,",
						"          EMPLOYEE_TYPE,",
						"          JOBCODE,",
						"          SUPERVISOR,",
						"          BIRTHDATE,",
						"          HIREDATE,",
						"          TERMINATIONDATE,",
						"          LOCATION,",
						"          STATUSDATE,",
						"          SITE_ID,",
						"          SRC_TYPE_HASH_KEY,",
						"          ExistPERSON_ID,",
						"          ExistPERSON_NBR",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selPersonUpdate",
						"dcPersonUpdate alterRow(updateIf(1==1)) ~> alterRowUpdate",
						"alterRowInsert sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          PERSON_ID as integer,",
						"          PERSON_NBR as string,",
						"          PERSON_FIRST_NM as string,",
						"          PERSON_LAST_NM as string,",
						"          STATUS as string,",
						"          DEPARTMENT as string,",
						"          TITLE as string,",
						"          EMPLOYEE_TYPE as string,",
						"          JOBCODE as string,",
						"          SUPERVISOR as string,",
						"          BIRTHDATE as date,",
						"          HIREDATE as date,",
						"          TERMINATIONDATE as date,",
						"          LOCATION as string,",
						"          SITE_ID as integer,",
						"          EFFECTIVE_DT as timestamp,",
						"          SRC_TYPE_HASH_KEY as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     staged: true,",
						"     allowCopyCommand: true,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     saveOrder: 2,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          PERSON_NBR,",
						"          PERSON_FIRST_NM,",
						"          PERSON_LAST_NM,",
						"          STATUS,",
						"          DEPARTMENT,",
						"          TITLE,",
						"          EMPLOYEE_TYPE,",
						"          JOBCODE,",
						"          SUPERVISOR,",
						"          BIRTHDATE,",
						"          HIREDATE,",
						"          TERMINATIONDATE,",
						"          LOCATION,",
						"          SITE_ID,",
						"          EFFECTIVE_DT,",
						"          PERSON_ID = NewPERSON_ID,",
						"          SRC_TYPE_HASH_KEY",
						"     )) ~> sinkPersonLd",
						"alterRowUpdate sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          PERSON_ID as integer,",
						"          PERSON_NBR as string,",
						"          PERSON_FIRST_NM as string,",
						"          PERSON_LAST_NM as string,",
						"          STATUS as string,",
						"          DEPARTMENT as string,",
						"          TITLE as string,",
						"          EMPLOYEE_TYPE as string,",
						"          JOBCODE as string,",
						"          SUPERVISOR as string,",
						"          BIRTHDATE as date,",
						"          HIREDATE as date,",
						"          TERMINATIONDATE as date,",
						"          LOCATION as string,",
						"          SITE_ID as integer,",
						"          EFFECTIVE_DT as timestamp,",
						"          SRC_TYPE_HASH_KEY as string",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['PERSON_NBR','SITE_ID'],",
						"     format: 'table',",
						"     staged: true,",
						"     allowCopyCommand: true,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     saveOrder: 1,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          PERSON_ID = ExistPERSON_ID,",
						"          PERSON_NBR = ExistPERSON_NBR,",
						"          PERSON_FIRST_NM,",
						"          PERSON_LAST_NM,",
						"          STATUS,",
						"          DEPARTMENT,",
						"          TITLE,",
						"          EMPLOYEE_TYPE,",
						"          JOBCODE,",
						"          SUPERVISOR,",
						"          BIRTHDATE,",
						"          HIREDATE,",
						"          TERMINATIONDATE,",
						"          LOCATION,",
						"          SITE_ID,",
						"          EFFECTIVE_DT,",
						"          SRC_TYPE_HASH_KEY",
						"     )) ~> sinkPersonUpdate"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/dp_Person_Dim_df1')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "AzureSynpMxmStgRefnAsset22",
								"type": "DatasetReference"
							},
							"name": "srcPersonLd"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd7",
								"type": "DatasetReference"
							},
							"name": "srcPersonSiteRefRd"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd7",
								"type": "DatasetReference"
							},
							"name": "PersonExistRowRd"
						},
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd7",
								"type": "DatasetReference"
							},
							"name": "MaxKey"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "SinkPersonInitialLoad1",
								"type": "DatasetReference"
							},
							"name": "sinkPersonLd"
						},
						{
							"dataset": {
								"referenceName": "SinkPersonInitialLoad1",
								"type": "DatasetReference"
							},
							"name": "sinkPersonUpdate"
						}
					],
					"transformations": [
						{
							"name": "dcPersonLd"
						},
						{
							"name": "skPersonLd"
						},
						{
							"name": "lkpPersonSite"
						},
						{
							"name": "selPersonExistRow"
						},
						{
							"name": "dcPersonHashKey"
						},
						{
							"name": "existsPerson"
						},
						{
							"name": "lookupPerson"
						},
						{
							"name": "splitPerson"
						},
						{
							"name": "joinPerson"
						},
						{
							"name": "dcPersonInsert"
						},
						{
							"name": "selPersonInsert"
						},
						{
							"name": "alterRowInsert"
						},
						{
							"name": "dcPersonUpdate"
						},
						{
							"name": "selPersonUpdate"
						},
						{
							"name": "alterRowUpdate"
						}
					],
					"scriptLines": [
						"source(output(",
						"          PERSON_NBR as string,",
						"          PERSON_FIRST_NM as string,",
						"          PERSON_LAST_NM as string,",
						"          STATUS as string,",
						"          DEPARTMENT as string,",
						"          TITLE as string,",
						"          EMPLOYEE_TYPE as string,",
						"          JOBCODE as string,",
						"          SUPERVISOR as string,",
						"          BIRTHDATE as date,",
						"          HIREDATE as date,",
						"          TERMINATIONDATE as date,",
						"          LOCATION as string,",
						"          LOCATIONSITE as string,",
						"          STATUSDATE as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: '\\nSELECT \\nPERSONID AS PERSON_NBR,\\nFIRSTNAME AS PERSON_FIRST_NM,\\nLASTNAME AS PERSON_LAST_NM,\\nSTATUS AS STATUS,\\nDEPARTMENT AS DEPARTMENT,\\nTITLE AS TITLE,\\nEMPLOYEETYPE AS EMPLOYEE_TYPE,\\nJOBCODE AS JOBCODE,\\nSUPERVISOR AS SUPERVISOR,\\nBIRTHDATE,\\nHIREDATE,\\nTERMINATIONDATE,\\nLOCATION,\\nLOCATIONSITE,\\nSTATUSDATE\\nFROM MXMSTG.STG_PERSON',",
						"     format: 'query',",
						"     staged: true) ~> srcPersonLd",
						"source(output(",
						"          SITE_ID as integer,",
						"          SITE_NM as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT SITE_ID,SITE_NM FROM MXMDW.SITE',",
						"     format: 'query',",
						"     staged: true) ~> srcPersonSiteRefRd",
						"source(output(",
						"          PERSON_ID as integer,",
						"          PERSON_NBR as string,",
						"          STATUS as string,",
						"          DEPARTMENT as string,",
						"          JOBCODE as string,",
						"          SUPERVISOR as string,",
						"          SRC_TYPE_HASH_KEY as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT PERSON_ID,PERSON_NBR,STATUS,DEPARTMENT,JOBCODE,SUPERVISOR,SRC_TYPE_HASH_KEY FROM MXMDW.PERSON',",
						"     format: 'query',",
						"     staged: true,",
						"     partitionBy('hash', 1)) ~> PersonExistRowRd",
						"source(output(",
						"          MAXKEY as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT MAXKEY=ISNULL(MAX(PERSON_ID),0) FROM MXMDW.PERSON',",
						"     format: 'query',",
						"     staged: true) ~> MaxKey",
						"lkpPersonSite derive(PERSON_FIRST_NM = iifNull(PERSON_FIRST_NM, 'NA', PERSON_FIRST_NM),",
						"          PERSON_LAST_NM = iifNull(PERSON_LAST_NM, 'NA', PERSON_LAST_NM),",
						"          STATUS = iifNull(STATUS, 'NA', STATUS),",
						"          DEPARTMENT = iifNull(DEPARTMENT, 'NA', DEPARTMENT),",
						"          TITLE = iifNull(TITLE, 'NA', TITLE),",
						"          EMPLOYEE_TYPE = iifNull(EMPLOYEE_TYPE, 'NA', EMPLOYEE_TYPE),",
						"          JOBCODE = iifNull(JOBCODE, 'NA', JOBCODE),",
						"          SUPERVISOR = iifNull(SUPERVISOR, 'NA', SUPERVISOR),",
						"          BIRTHDATE = iifNull(BIRTHDATE, toDate('1900/01/01','yyyy/MM/dd'), BIRTHDATE),",
						"          HIREDATE = iifNull(HIREDATE, toDate('1900/01/01','yyyy/MM/dd'), HIREDATE),",
						"          LOCATION = iifNull(LOCATION, 'NA', LOCATION)) ~> dcPersonLd",
						"joinPerson keyGenerate(output(NewPERSON_ID as long),",
						"     startAt: 1L,",
						"     stepValue: 1L,",
						"     partitionBy('hash', 1)) ~> skPersonLd",
						"srcPersonLd, srcPersonSiteRefRd lookup(LOCATIONSITE == SITE_NM,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lkpPersonSite",
						"PersonExistRowRd select(mapColumn(",
						"          ExistPERSON_ID = PERSON_ID,",
						"          ExistPERSON_NBR = PERSON_NBR,",
						"          ExistSTATUS = STATUS,",
						"          ExistDEPARTMENT = DEPARTMENT,",
						"          ExistJOBCODE = JOBCODE,",
						"          ExistSUPERVISOR = SUPERVISOR,",
						"          ExistSRC_TYPE_HASH_KEY = SRC_TYPE_HASH_KEY",
						"     ),",
						"     partitionBy('hash', 1),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selPersonExistRow",
						"dcPersonLd derive(SRC_TYPE_HASH_KEY = sha2(256,PERSON_NBR,STATUS,DEPARTMENT,JOBCODE,SUPERVISOR)) ~> dcPersonHashKey",
						"dcPersonHashKey, selPersonExistRow exists(PERSON_NBR == ExistPERSON_NBR",
						"     && STATUS == ExistSTATUS",
						"     && DEPARTMENT == ExistDEPARTMENT",
						"     && JOBCODE == ExistJOBCODE",
						"     && SUPERVISOR == ExistSUPERVISOR,",
						"     negate:true,",
						"     partitionBy('hash', 1),",
						"     broadcast: 'right')~> existsPerson",
						"existsPerson, selPersonExistRow lookup(PERSON_NBR == ExistPERSON_NBR,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     partitionBy('hash', 1),",
						"     broadcast: 'auto')~> lookupPerson",
						"lookupPerson split(isNull(ExistPERSON_ID),",
						"     disjoint: false,",
						"     partitionBy('hash', 1)) ~> splitPerson@(NewItem, UpdateItem)",
						"splitPerson@NewItem, MaxKey join(1==1,",
						"     joinType:'cross',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     partitionBy('hash', 1),",
						"     broadcast: 'auto')~> joinPerson",
						"skPersonLd derive(NewPERSON_ID = NewPERSON_ID + MAXKEY,",
						"          EFFECTIVE_DT = currentTimestamp()) ~> dcPersonInsert",
						"dcPersonInsert select(mapColumn(",
						"          PERSON_NBR,",
						"          PERSON_FIRST_NM,",
						"          PERSON_LAST_NM,",
						"          STATUS,",
						"          DEPARTMENT,",
						"          TITLE,",
						"          EMPLOYEE_TYPE,",
						"          JOBCODE,",
						"          SUPERVISOR,",
						"          BIRTHDATE,",
						"          HIREDATE,",
						"          TERMINATIONDATE,",
						"          LOCATION,",
						"          SITE_ID,",
						"          SRC_TYPE_HASH_KEY,",
						"          NewPERSON_ID,",
						"          EFFECTIVE_DT",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selPersonInsert",
						"selPersonInsert alterRow(insertIf(1==1)) ~> alterRowInsert",
						"selPersonUpdate derive(EFFECTIVE_DT = currentTimestamp()) ~> dcPersonUpdate",
						"splitPerson@UpdateItem select(mapColumn(",
						"          PERSON_FIRST_NM,",
						"          PERSON_NBR,",
						"          PERSON_LAST_NM,",
						"          STATUS,",
						"          DEPARTMENT,",
						"          TITLE,",
						"          EMPLOYEE_TYPE,",
						"          JOBCODE,",
						"          SUPERVISOR,",
						"          BIRTHDATE,",
						"          HIREDATE,",
						"          TERMINATIONDATE,",
						"          LOCATION,",
						"          STATUSDATE,",
						"          SITE_ID,",
						"          SRC_TYPE_HASH_KEY,",
						"          ExistPERSON_ID,",
						"          ExistPERSON_NBR",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selPersonUpdate",
						"dcPersonUpdate alterRow(updateIf(1==1)) ~> alterRowUpdate",
						"alterRowInsert sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          PERSON_ID as integer,",
						"          PERSON_NBR as string,",
						"          PERSON_FIRST_NM as string,",
						"          PERSON_LAST_NM as string,",
						"          STATUS as string,",
						"          DEPARTMENT as string,",
						"          TITLE as string,",
						"          EMPLOYEE_TYPE as string,",
						"          JOBCODE as string,",
						"          SUPERVISOR as string,",
						"          BIRTHDATE as date,",
						"          HIREDATE as date,",
						"          TERMINATIONDATE as date,",
						"          LOCATION as string,",
						"          SITE_ID as integer,",
						"          EFFECTIVE_DT as timestamp,",
						"          SRC_TYPE_HASH_KEY as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     staged: true,",
						"     allowCopyCommand: true,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     saveOrder: 2,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          PERSON_NBR,",
						"          PERSON_FIRST_NM,",
						"          PERSON_LAST_NM,",
						"          STATUS,",
						"          DEPARTMENT,",
						"          TITLE,",
						"          EMPLOYEE_TYPE,",
						"          JOBCODE,",
						"          SUPERVISOR,",
						"          BIRTHDATE,",
						"          HIREDATE,",
						"          TERMINATIONDATE,",
						"          LOCATION,",
						"          SITE_ID,",
						"          EFFECTIVE_DT,",
						"          PERSON_ID = NewPERSON_ID,",
						"          SRC_TYPE_HASH_KEY",
						"     )) ~> sinkPersonLd",
						"alterRowUpdate sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          PERSON_ID as integer,",
						"          PERSON_NBR as string,",
						"          PERSON_FIRST_NM as string,",
						"          PERSON_LAST_NM as string,",
						"          STATUS as string,",
						"          DEPARTMENT as string,",
						"          TITLE as string,",
						"          EMPLOYEE_TYPE as string,",
						"          JOBCODE as string,",
						"          SUPERVISOR as string,",
						"          BIRTHDATE as date,",
						"          HIREDATE as date,",
						"          TERMINATIONDATE as date,",
						"          LOCATION as string,",
						"          SITE_ID as integer,",
						"          EFFECTIVE_DT as timestamp,",
						"          SRC_TYPE_HASH_KEY as string",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['PERSON_NBR','SITE_ID'],",
						"     format: 'table',",
						"     staged: true,",
						"     allowCopyCommand: true,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     saveOrder: 1,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          PERSON_ID = ExistPERSON_ID,",
						"          PERSON_NBR = ExistPERSON_NBR,",
						"          PERSON_FIRST_NM,",
						"          PERSON_LAST_NM,",
						"          STATUS,",
						"          DEPARTMENT,",
						"          TITLE,",
						"          EMPLOYEE_TYPE,",
						"          JOBCODE,",
						"          SUPERVISOR,",
						"          BIRTHDATE,",
						"          HIREDATE,",
						"          TERMINATIONDATE,",
						"          LOCATION,",
						"          SITE_ID,",
						"          EFFECTIVE_DT,",
						"          SRC_TYPE_HASH_KEY",
						"     )) ~> sinkPersonUpdate"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/dp_Update_Parent_ActLabHrs_Ops_df')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd",
								"type": "DatasetReference"
							},
							"name": "UpdateParentActLabHrsOps"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "SinkOperationLd",
								"type": "DatasetReference"
							},
							"name": "sinkUpdateParentActLabHrs"
						}
					],
					"transformations": [
						{
							"name": "filterActLabHrs"
						},
						{
							"name": "aggActLabHrs"
						},
						{
							"name": "alterRowActLabHrs"
						}
					],
					"scriptLines": [
						"source(output(",
						"          WONUM as string,",
						"          PARENT as string,",
						"          SITE_ID as integer,",
						"          ISTASK as integer,",
						"          ACTLABHRS as decimal(18,9)",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT DISTINCT WONUM, PARENT,SITE_ID,ISTASK,ACTLABHRS FROM MXMDW.OPERATION WHERE ACTLABHRS>0 AND CURRENT_RECORD_IND=1',",
						"     format: 'query',",
						"     staged: true) ~> UpdateParentActLabHrsOps",
						"UpdateParentActLabHrsOps filter(ISTASK==1) ~> filterActLabHrs",
						"filterActLabHrs aggregate(groupBy(PARENT,",
						"          SITE_ID),",
						"     SumACTLABHRS = sum(ACTLABHRS)) ~> aggActLabHrs",
						"aggActLabHrs alterRow(updateIf(1==1)) ~> alterRowActLabHrs",
						"alterRowActLabHrs sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          OPERATION_ID as integer,",
						"          WONUM as string,",
						"          PARENT as string,",
						"          GOVTWONUM as string,",
						"          ORGANIZATION_ID as integer,",
						"          SITE_ID as integer,",
						"          LOCATION_ID as integer,",
						"          ASSET_ID as integer,",
						"          PERSON_ID as integer,",
						"          JP_ID as integer,",
						"          PERSON_GROUP_ID as integer,",
						"          STATUS as string,",
						"          WORKTYPE as string,",
						"          TASKID as integer,",
						"          ISTASK as integer,",
						"          DESCRIPTION as string,",
						"          PLUSCJREVNUM as integer,",
						"          WOPRIORITY as string,",
						"          WO_CHANGEDATE as timestamp,",
						"          WO_STATUS_CHANGEDATE as timestamp,",
						"          WO_STATUS_CHANGEBY as string,",
						"          STATUSDATE as timestamp,",
						"          PMDUEDATE as timestamp,",
						"          TARGSTARTDATE as timestamp,",
						"          TARGCOMPDATE as timestamp,",
						"          REPORTDATE as timestamp,",
						"          ACTLABHRS as decimal(18,9),",
						"          ACTSTART as timestamp,",
						"          ACTFINISH as timestamp,",
						"          ACTINTLABHRS as decimal(18,9),",
						"          ESTDUR as decimal(18,9),",
						"          WOGROUP as string,",
						"          PERSON_GROUP as string,",
						"          CAL_PMDUEDT as timestamp,",
						"          WORKTYPE_CM_PM as string,",
						"          REPORTMONTH_YEAR as string,",
						"          REPORTDATE_MONTH as string,",
						"          REPORTDATE_CM_PM as timestamp,",
						"          PLUSCFREQUENCY as integer,",
						"          PLUSCFREQUNIT as string,",
						"          PMNEXTDUEDATE as date,",
						"          PMNUM as string,",
						"          AVAILABLE_MANHOUR as integer,",
						"          PARENT_ACTLABHRS as decimal(18,9),",
						"          SNAPSHOT_DATE as timestamp,",
						"          CURRENT_RECORD_IND as integer,",
						"          EFFECTIVE_DT as timestamp,",
						"          STATUS_FLAG as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['WONUM','SITE_ID'],",
						"     format: 'table',",
						"     staged: true,",
						"     allowCopyCommand: true,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          WONUM = PARENT,",
						"          SITE_ID,",
						"          PARENT_ACTLABHRS = SumACTLABHRS",
						"     )) ~> sinkUpdateParentActLabHrs"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/dp_Update_Parent_ActLabHrs_Ops_df1')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "OrgSiteRefRd7",
								"type": "DatasetReference"
							},
							"name": "UpdateParentActLabHrsOps"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "SinkOperationLd22",
								"type": "DatasetReference"
							},
							"name": "sinkUpdateParentActLabHrs"
						}
					],
					"transformations": [
						{
							"name": "filterActLabHrs"
						},
						{
							"name": "aggActLabHrs"
						},
						{
							"name": "alterRowActLabHrs"
						}
					],
					"scriptLines": [
						"source(output(",
						"          WONUM as string,",
						"          PARENT as string,",
						"          SITE_ID as integer,",
						"          ISTASK as integer,",
						"          ACTLABHRS as decimal(18,9)",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT DISTINCT WONUM, PARENT,SITE_ID,ISTASK,ACTLABHRS FROM MXMDW.OPERATION WHERE ACTLABHRS>0 AND CURRENT_RECORD_IND=1',",
						"     format: 'query',",
						"     staged: true) ~> UpdateParentActLabHrsOps",
						"UpdateParentActLabHrsOps filter(ISTASK==1) ~> filterActLabHrs",
						"filterActLabHrs aggregate(groupBy(PARENT,",
						"          SITE_ID),",
						"     SumACTLABHRS = sum(ACTLABHRS)) ~> aggActLabHrs",
						"aggActLabHrs alterRow(updateIf(1==1)) ~> alterRowActLabHrs",
						"alterRowActLabHrs sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          OPERATION_ID as integer,",
						"          WONUM as string,",
						"          PARENT as string,",
						"          GOVTWONUM as string,",
						"          ORGANIZATION_ID as integer,",
						"          SITE_ID as integer,",
						"          LOCATION_ID as integer,",
						"          ASSET_ID as integer,",
						"          PERSON_ID as integer,",
						"          JP_ID as integer,",
						"          PERSON_GROUP_ID as integer,",
						"          STATUS as string,",
						"          WORKTYPE as string,",
						"          TASKID as integer,",
						"          ISTASK as integer,",
						"          DESCRIPTION as string,",
						"          PLUSCJREVNUM as integer,",
						"          WOPRIORITY as string,",
						"          WO_CHANGEDATE as timestamp,",
						"          WO_STATUS_CHANGEDATE as timestamp,",
						"          WO_STATUS_CHANGEBY as string,",
						"          STATUSDATE as timestamp,",
						"          PMDUEDATE as timestamp,",
						"          TARGSTARTDATE as timestamp,",
						"          TARGCOMPDATE as timestamp,",
						"          REPORTDATE as timestamp,",
						"          ACTLABHRS as decimal(18,9),",
						"          ACTSTART as timestamp,",
						"          ACTFINISH as timestamp,",
						"          ACTINTLABHRS as decimal(18,9),",
						"          ESTDUR as decimal(18,9),",
						"          WOGROUP as string,",
						"          PERSON_GROUP as string,",
						"          CAL_PMDUEDT as timestamp,",
						"          WORKTYPE_CM_PM as string,",
						"          REPORTMONTH_YEAR as string,",
						"          REPORTDATE_MONTH as string,",
						"          REPORTDATE_CM_PM as timestamp,",
						"          PLUSCFREQUENCY as integer,",
						"          PLUSCFREQUNIT as string,",
						"          PMNEXTDUEDATE as date,",
						"          PMNUM as string,",
						"          AVAILABLE_MANHOUR as integer,",
						"          PARENT_ACTLABHRS as decimal(18,9),",
						"          SNAPSHOT_DATE as timestamp,",
						"          CURRENT_RECORD_IND as integer,",
						"          EFFECTIVE_DT as timestamp,",
						"          STATUS_FLAG as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['WONUM','SITE_ID'],",
						"     format: 'table',",
						"     staged: true,",
						"     allowCopyCommand: true,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError',",
						"     mapColumn(",
						"          WONUM = PARENT,",
						"          SITE_ID,",
						"          PARENT_ACTLABHRS = SumACTLABHRS",
						"     )) ~> sinkUpdateParentActLabHrs"
					]
				}
			},
			"dependsOn": []
		}
	]
}